var documenterSearchIndex = {"docs":
[{"location":"api_reference/#API-Reference","page":"API Reference","title":"API Reference","text":"This document provides detailed API reference for OnlineResamplers.jl.","category":"section"},{"location":"api_reference/#Table-of-Contents","page":"API Reference","title":"Table of Contents","text":"Core Types\nMarketDataPoint\nOHLC\nTimeWindow\nAbstract Types\nAbstractResampler\nResampler Types\nMarketResampler\nOHLCResampler\nMeanResampler\nSumResampler\nCore Functions\nOnlineStatsBase Interface\nUtility Functions\nType Constructors\nReturn Values\n\n","category":"section"},{"location":"api_reference/#Core-Types","page":"API Reference","title":"Core Types","text":"","category":"section"},{"location":"api_reference/#MarketDataPoint","page":"API Reference","title":"MarketDataPoint","text":"struct MarketDataPoint{T,P,V}\n    datetime::T\n    price::P\n    volume::V\nend\n\nDescription: Fundamental data structure representing a single market observation.\n\nType Parameters:\n\nT: Timestamp type (e.g., DateTime, NanoDate, ZonedDateTime)\nP: Price type (e.g., Float64, FixedDecimal{Int64,4}, Rational{Int})\nV: Volume type (e.g., Float64, FixedDecimal{Int64,2}, Int64)\n\nConstructors:\n\n# Automatic type inference for common case\nMarketDataPoint(datetime::DateTime, price::Real, volume::Real)\n\n# Explicit type specification\nMarketDataPoint{T,P,V}(datetime::T, price::P, volume::V)\n\nExamples:\n\n# Basic construction\ndata = MarketDataPoint(DateTime(2024,1,1,9,30,0), 100.0, 1000.0)\n\n# High-precision construction\nusing FixedPointDecimals\nprecise_data = MarketDataPoint{DateTime, FixedDecimal{Int64,4}, FixedDecimal{Int64,2}}(\n    DateTime(2024,1,1,9,30,0), FixedDecimal{Int64,4}(100.1234), FixedDecimal{Int64,2}(1000.50)\n)\n\n","category":"section"},{"location":"api_reference/#OHLC","page":"API Reference","title":"OHLC","text":"struct OHLC{P}\n    open::P\n    high::P\n    low::P\n    close::P\nend\n\nDescription: Structure representing Open, High, Low, Close price data for a time period.\n\nType Parameters:\n\nP: Price type matching the price type used in market data\n\nFields:\n\nopen::P: First price in the time period\nhigh::P: Highest price during the period\nlow::P: Lowest price during the period\nclose::P: Last price in the time period\n\nExamples:\n\n# Create OHLC manually\nohlc = OHLC{Float64}(100.0, 105.0, 98.0, 102.0)\n\n# Access components\nprintln(\"Range: $(ohlc.high - ohlc.low)\")\nprintln(\"Change: $(ohlc.close - ohlc.open)\")\n\n","category":"section"},{"location":"api_reference/#TimeWindow","page":"API Reference","title":"TimeWindow","text":"struct TimeWindow{T}\n    start_time::T\n    period::Period\nend\n\nDescription: Represents a time interval for data aggregation.\n\nType Parameters:\n\nT: Timestamp type matching the datetime type used in market data\n\nFields:\n\nstart_time::T: Beginning of the time window (inclusive)\nperiod::Period: Duration of the window (e.g., Minute(1), Hour(1))\n\nExamples:\n\n# Create 1-minute window\nwindow = TimeWindow{DateTime}(DateTime(2024,1,1,9,30,0), Minute(1))\n\n# Check window boundaries\nend_time = window_end(window)  # DateTime(2024,1,1,9,31,0)\nnext = next_window(window)     # Starts at 9:31:00\n\n","category":"section"},{"location":"api_reference/#Abstract-Types","page":"API Reference","title":"Abstract Types","text":"","category":"section"},{"location":"api_reference/#AbstractResampler","page":"API Reference","title":"AbstractResampler","text":"abstract type AbstractResampler{T,P,V} <: OnlineStat{MarketDataPoint{T,P,V}} end\n\nDescription: Base type for all market data resamplers, extending OnlineStatsBase functionality.\n\nType Parameters:\n\nT: Timestamp type\nP: Price type\nV: Volume type\n\nRequired Interface (for subtypes):\n\nOnlineStatsBase._fit!(resampler, data::MarketDataPoint{T,P,V})\nOnlineStatsBase.value(resampler)\nOnlineStatsBase._merge!(r1, r2) (optional, for parallel processing)\n\nAutomatic Interface (inherited from OnlineStatsBase):\n\nfit!(resampler, data): Public fitting function\nnobs(resampler): Number of observations processed\nmerge!(r1, r2): Public merging function\n\n","category":"section"},{"location":"api_reference/#Resampler-Types","page":"API Reference","title":"Resampler Types","text":"","category":"section"},{"location":"api_reference/#MarketResampler","page":"API Reference","title":"MarketResampler","text":"struct MarketResampler{T,P,V} <: OnlineStat{MarketDataPoint{T,P,V}}\n    price_resampler::AbstractResampler{T,P,V}\n    volume_resampler::AbstractResampler{T,P,V}\nend\n\nDescription: Main composite resampler combining price and volume strategies.\n\nConstructors:\n\n# Default types with price method selection\nMarketResampler(period::Period; price_method::Symbol = :ohlc, validate_chronological::Bool = false)\n\n# Explicit types with price method selection\nMarketResampler{T,P,V}(period::Period; price_method::Symbol = :ohlc, validate_chronological::Bool = false)\n\nParameters:\n\nperiod: Time period for resampling (e.g., Minute(1), Second(30))\nprice_method: Either :ohlc or :mean\nvalidate_chronological: If true, validates that data points arrive in chronological order and throws ArgumentError for out-of-order data\n\nReturn Value: When calling value(resampler):\n\n(\n    price = price_resampler_result,  # OHLC or Mean result\n    volume = volume_sum,             # Total volume\n    window = current_time_window     # TimeWindow\n)\n\nExamples:\n\n# OHLC resampler (default)\nohlc_resampler = MarketResampler(Minute(1))\n\n# Mean price resampler\nmean_resampler = MarketResampler(Minute(5), price_method=:mean)\n\n# High-precision resampler\nusing FixedPointDecimals\nprecision_resampler = MarketResampler{DateTime, FixedDecimal{Int64,4}, FixedDecimal{Int64,2}}(\n    Minute(1), price_method=:ohlc\n)\n\n# Chronological validation enabled\nvalidated_resampler = MarketResampler(Minute(1), validate_chronological=true)\nfit!(validated_resampler, MarketDataPoint(DateTime(2024,1,1,9,30,0), 100.0, 1000.0))\n# This will throw ArgumentError due to out-of-order timestamp\n# fit!(validated_resampler, MarketDataPoint(DateTime(2024,1,1,9,29,0), 99.0, 800.0))\n\n","category":"section"},{"location":"api_reference/#OHLCResampler","page":"API Reference","title":"OHLCResampler","text":"mutable struct OHLCResampler{T,P,V} <: AbstractResampler{T,P,V}\n    period::Period\n    current_window::Union{TimeWindow{T}, Nothing}\n    ohlc::Union{OHLC{P}, Nothing}\n    volume_sum::V\n    count::Int\nend\n\nDescription: Resampler that aggregates data into OHLC format.\n\nConstructors:\n\n# Default types\nOHLCResampler(period::Period; validate_chronological::Bool = false)\n\n# Explicit types\nOHLCResampler{T,P,V}(period::Period; validate_chronological::Bool = false)\n\nReturn Value: When calling value(resampler):\n\n(\n    ohlc = OHLC{P}(...) | nothing,  # OHLC structure or nothing if no data\n    volume = volume_sum,             # Total volume in current window\n    window = current_window          # Current TimeWindow\n)\n\nExamples:\n\nresampler = OHLCResampler(Minute(1))\nfit!(resampler, MarketDataPoint(now(), 100.0, 1000.0))\nresult = value(resampler)\nprintln(result.ohlc)  # OHLC(100.0, 100.0, 100.0, 100.0)\n\n","category":"section"},{"location":"api_reference/#MeanResampler","page":"API Reference","title":"MeanResampler","text":"mutable struct MeanResampler{T,P,V} <: AbstractResampler{T,P,V}\n    period::Period\n    current_window::Union{TimeWindow{T}, Nothing}\n    price_sum::P\n    volume_sum::V\n    count::Int\nend\n\nDescription: Resampler that calculates mean prices over time periods.\n\nConstructors:\n\n# Default types\nMeanResampler(period::Period; validate_chronological::Bool = false)\n\n# Explicit types\nMeanResampler{T,P,V}(period::Period; validate_chronological::Bool = false)\n\nReturn Value: When calling value(resampler):\n\n(\n    mean_price = price_sum / count,  # Average price in window\n    volume = volume_sum,             # Total volume in current window\n    window = current_window          # Current TimeWindow\n)\n\nExamples:\n\nresampler = MeanResampler(Minute(5))\nfit!(resampler, MarketDataPoint(now(), 100.0, 1000.0))\nfit!(resampler, MarketDataPoint(now(), 110.0, 500.0))\nresult = value(resampler)\nprintln(result.mean_price)  # 105.0\n\n","category":"section"},{"location":"api_reference/#SumResampler","page":"API Reference","title":"SumResampler","text":"mutable struct SumResampler{T,P,V} <: AbstractResampler{T,P,V}\n    period::Period\n    current_window::Union{TimeWindow{T}, Nothing}\n    sum::V\n    count::Int\nend\n\nDescription: Resampler that sums values over time periods (typically used for volumes).\n\nConstructors:\n\n# Default types\nSumResampler(period::Period; validate_chronological::Bool = false)\n\n# Explicit types\nSumResampler{T,P,V}(period::Period; validate_chronological::Bool = false)\n\nReturn Value: When calling value(resampler):\n\n(\n    sum = accumulated_sum,    # Sum of values in current window\n    window = current_window   # Current TimeWindow\n)\n\nExamples:\n\nresampler = SumResampler(Minute(1))\nfit!(resampler, MarketDataPoint(now(), 100.0, 1000.0))  # Uses volume\nfit!(resampler, MarketDataPoint(now(), 105.0, 500.0))   # Uses volume\nresult = value(resampler)\nprintln(result.sum)  # 1500.0\n\n","category":"section"},{"location":"api_reference/#Core-Functions","page":"API Reference","title":"Core Functions","text":"","category":"section"},{"location":"api_reference/#OnlineStatsBase-Interface","page":"API Reference","title":"OnlineStatsBase Interface","text":"","category":"section"},{"location":"api_reference/#fit!(resampler,-data)","page":"API Reference","title":"fit!(resampler, data)","text":"fit!(resampler::AbstractResampler, data::MarketDataPoint)\n\nDescription: Process a new market data point through the resampler.\n\nArguments:\n\nresampler: Any resampler instance\ndata: MarketDataPoint with compatible types\n\nReturns: The resampler instance (for chaining)\n\nSide Effects: Updates internal state; may trigger window transitions\n\nExamples:\n\nresampler = MarketResampler(Minute(1))\ndata = MarketDataPoint(DateTime(2024,1,1,9,30,0), 100.0, 1000.0)\nfit!(resampler, data)\n\n# Chaining\nfit!(fit!(resampler, data1), data2)\n\n","category":"section"},{"location":"api_reference/#value(resampler)","page":"API Reference","title":"value(resampler)","text":"value(resampler::AbstractResampler)\n\nDescription: Extract current aggregated values from the resampler.\n\nArguments:\n\nresampler: Any resampler instance\n\nReturns: Named tuple with resampler-specific structure (see individual resampler documentation)\n\nExamples:\n\nresampler = OHLCResampler(Minute(1))\n# ... fit data ...\nresult = value(resampler)\nprintln(\"OHLC: $(result.ohlc)\")\nprintln(\"Volume: $(result.volume)\")\n\n","category":"section"},{"location":"api_reference/#nobs(resampler)","page":"API Reference","title":"nobs(resampler)","text":"nobs(resampler::AbstractResampler) -> Int\n\nDescription: Get the number of observations processed in the current time window.\n\nArguments:\n\nresampler: Any resampler instance\n\nReturns: Integer count of data points in current window\n\nExamples:\n\nresampler = MarketResampler(Minute(1))\nprintln(\"Initial count: $(nobs(resampler))\")  # 0\nfit!(resampler, data)\nprintln(\"After data: $(nobs(resampler))\")     # 1\n\n","category":"section"},{"location":"api_reference/#merge!(r1,-r2)","page":"API Reference","title":"merge!(r1, r2)","text":"merge!(r1::T, r2::T) where T <: AbstractResampler\n\nDescription: Merge two resamplers of the same type for parallel processing.\n\nArguments:\n\nr1: Target resampler (will be modified)\nr2: Source resampler (will be consumed)\n\nReturns: Modified r1 containing combined results\n\nRequirements: Both resamplers must have compatible types and time windows\n\nExamples:\n\n# Parallel processing example\nr1 = OHLCResampler(Minute(1))\nr2 = OHLCResampler(Minute(1))\n\n# Process different data chunks\nfit!(r1, data_chunk_1...)\nfit!(r2, data_chunk_2...)\n\n# Combine results\nmerge!(r1, r2)\ncombined_result = value(r1)\n\n","category":"section"},{"location":"api_reference/#Utility-Functions","page":"API Reference","title":"Utility Functions","text":"","category":"section"},{"location":"api_reference/#window_end(window)","page":"API Reference","title":"window_end(window)","text":"window_end(window::TimeWindow{T}) -> T\n\nDescription: Calculate the end time of a time window.\n\nArguments:\n\nwindow: TimeWindow instance\n\nReturns: End timestamp (start_time + period)\n\nExamples:\n\nwindow = TimeWindow{DateTime}(DateTime(2024,1,1,9,30,0), Minute(1))\nend_time = window_end(window)  # DateTime(2024,1,1,9,31,0)\n\n","category":"section"},{"location":"api_reference/#belongs*to*window(datetime,-window)","page":"API Reference","title":"belongstowindow(datetime, window)","text":"belongs_to_window(datetime::T, window::TimeWindow{T}) -> Bool\n\nDescription: Check if a timestamp falls within a time window.\n\nArguments:\n\ndatetime: Timestamp to check\nwindow: TimeWindow to check against\n\nReturns: true if timestamp is in [starttime, endtime), false otherwise\n\nNote: Window is inclusive of start time, exclusive of end time\n\nExamples:\n\nwindow = TimeWindow{DateTime}(DateTime(2024,1,1,9,30,0), Minute(1))\nbelongs_to_window(DateTime(2024,1,1,9,30,30), window)  # true\nbelongs_to_window(DateTime(2024,1,1,9,31,0), window)   # false (next window)\n\n","category":"section"},{"location":"api_reference/#next_window(window)","page":"API Reference","title":"next_window(window)","text":"next_window(window::TimeWindow{T}) -> TimeWindow{T}\n\nDescription: Create the next consecutive time window.\n\nArguments:\n\nwindow: Current time window\n\nReturns: New TimeWindow starting at current window's end time\n\nExamples:\n\ncurrent = TimeWindow{DateTime}(DateTime(2024,1,1,9,30,0), Minute(1))\nnext = next_window(current)\n# next.start_time == DateTime(2024,1,1,9,31,0)\n# next.period == Minute(1)\n\n","category":"section"},{"location":"api_reference/#Type-Constructors","page":"API Reference","title":"Type Constructors","text":"","category":"section"},{"location":"api_reference/#Default-Type-Constructors","page":"API Reference","title":"Default Type Constructors","text":"These constructors use DateTime, Float64, Float64 as default types:\n\nMarketResampler(period::Period; price_method=:ohlc, validate_chronological=false)\nOHLCResampler(period::Period; validate_chronological=false)\nMeanResampler(period::Period; validate_chronological=false)\nSumResampler(period::Period; validate_chronological=false)\nMarketDataPoint(datetime::DateTime, price::Real, volume::Real)","category":"section"},{"location":"api_reference/#Explicit-Type-Constructors","page":"API Reference","title":"Explicit Type Constructors","text":"For custom numeric types or high-precision applications:\n\nMarketResampler{T,P,V}(period::Period; price_method=:ohlc, validate_chronological=false)\nOHLCResampler{T,P,V}(period::Period; validate_chronological=false)\nMeanResampler{T,P,V}(period::Period; validate_chronological=false)\nSumResampler{T,P,V}(period::Period; validate_chronological=false)\nMarketDataPoint{T,P,V}(datetime::T, price::P, volume::V)\nOHLC{P}(open::P, high::P, low::P, close::P)\nTimeWindow{T}(start_time::T, period::Period)\n\n","category":"section"},{"location":"api_reference/#Return-Values","page":"API Reference","title":"Return Values","text":"","category":"section"},{"location":"api_reference/#MarketResampler-value()-Return","page":"API Reference","title":"MarketResampler value() Return","text":"(\n    price = (\n        ohlc = OHLC{P}(...) | nothing,     # If using :ohlc method\n        # OR\n        mean_price = P(...),               # If using :mean method\n        volume = V(...),                   # Volume from price resampler\n        window = TimeWindow{T}(...)        # Current window\n    ),\n    volume = V(...),                       # Total volume (same as price.volume)\n    window = TimeWindow{T}(...)            # Current window (same as price.window)\n)","category":"section"},{"location":"api_reference/#OHLCResampler-value()-Return","page":"API Reference","title":"OHLCResampler value() Return","text":"(\n    ohlc = OHLC{P}(...) | nothing,    # OHLC data or nothing if no data yet\n    volume = V(...),                  # Accumulated volume in current window\n    window = TimeWindow{T}(...) | nothing  # Current window or nothing if no data yet\n)","category":"section"},{"location":"api_reference/#MeanResampler-value()-Return","page":"API Reference","title":"MeanResampler value() Return","text":"(\n    mean_price = P(...),              # Average price in current window\n    volume = V(...),                  # Accumulated volume in current window\n    window = TimeWindow{T}(...) | nothing  # Current window or nothing if no data yet\n)","category":"section"},{"location":"api_reference/#SumResampler-value()-Return","page":"API Reference","title":"SumResampler value() Return","text":"(\n    sum = V(...),                     # Sum of values in current window\n    window = TimeWindow{T}(...) | nothing  # Current window or nothing if no data yet\n)\n\n","category":"section"},{"location":"api_reference/#Type-Compatibility","page":"API Reference","title":"Type Compatibility","text":"","category":"section"},{"location":"api_reference/#Supported-Period-Types","page":"API Reference","title":"Supported Period Types","text":"All Julia Dates.Period subtypes are supported:\n\nNanosecond, Microsecond, Millisecond\nSecond, Minute, Hour\nDay, Week, Month, Year","category":"section"},{"location":"api_reference/#Supported-Timestamp-Types","page":"API Reference","title":"Supported Timestamp Types","text":"Any type T that supports:\n\nArithmetic with Period types (T + Period -> T)\nComparison operations (<, <=, ==, >=, >)\nfloor(datetime::T, period::Period) -> T\n\nCommon examples:\n\nDateTime (from Dates.jl)\nNanoDate (from NanoDates.jl)\nZonedDateTime (from TimeZones.jl)","category":"section"},{"location":"api_reference/#Supported-Numeric-Types","page":"API Reference","title":"Supported Numeric Types","text":"Any numeric type that supports:\n\nzero(Type) and one(Type) for initialization\nBasic arithmetic (+, -, *, /)\nComparison operations (<, >, min, max)\n\nCommon examples:\n\nFloat64, Float32, BigFloat\nFixedDecimal{T,N} (from FixedPointDecimals.jl)\nRational{T} (built-in Julia type)\nInt64, Int32, BigInt (for volumes)\n\n","category":"section"},{"location":"api_reference/#Performance-Notes","page":"API Reference","title":"Performance Notes","text":"","category":"section"},{"location":"api_reference/#Memory-Complexity","page":"API Reference","title":"Memory Complexity","text":"Space: O(1) - Constant memory usage regardless of data volume\nAllocations: Zero allocations in steady-state processing","category":"section"},{"location":"api_reference/#Time-Complexity","page":"API Reference","title":"Time Complexity","text":"fit!(): O(1) - Constant time per operation\nvalue(): O(1) - Constant time access\nmerge!(): O(1) - Constant time merge operation","category":"section"},{"location":"api_reference/#Type-Stability","page":"API Reference","title":"Type Stability","text":"All operations are type-stable when using concrete types, enabling Julia's compiler optimizations.","category":"section"},{"location":"api_reference/#SIMD-Optimization","page":"API Reference","title":"SIMD Optimization","text":"Numeric operations automatically leverage Julia's SIMD capabilities when using appropriate numeric types.","category":"section"},{"location":"edge_cases/#Edge-Cases-and-Limitations","page":"Edge Cases & Limitations","title":"Edge Cases and Limitations","text":"This document covers important edge cases, limitations, and unexpected behaviors when using OnlineResamplers.jl.","category":"section"},{"location":"edge_cases/#Table-of-Contents","page":"Edge Cases & Limitations","title":"Table of Contents","text":"Out-of-Order Data\nEmpty Windows\nSingle Data Points\nType Mismatches\nVery Large Time Gaps\nPrecision Issues\nMemory Considerations\n\n","category":"section"},{"location":"edge_cases/#Out-of-Order-Data","page":"Edge Cases & Limitations","title":"Out-of-Order Data","text":"âš ï¸ CRITICAL BEHAVIOR: OnlineResamplers is designed for streaming data and assumes chronological order. Out-of-order data can cause unexpected behavior.","category":"section"},{"location":"edge_cases/#The-Problem","page":"Edge Cases & Limitations","title":"The Problem","text":"When data points arrive out of chronological order, OnlineResamplers will:\n\nAlways move to the new data's time window\nFinalize and lose all data from the previous window\nReset counters and aggregations for the new window","category":"section"},{"location":"edge_cases/#Example-of-the-Issue","page":"Edge Cases & Limitations","title":"Example of the Issue","text":"using OnlineResamplers, OnlineStatsBase, Dates\n\nresampler = MarketResampler(Minute(1))\n\n# Process some data in window 1 (9:30-9:31)\nfit!(resampler, MarketDataPoint(DateTime(2024, 1, 1, 9, 30, 0), 100.0, 1000.0))\nfit!(resampler, MarketDataPoint(DateTime(2024, 1, 1, 9, 30, 30), 105.0, 800.0))\n\n# Move to window 2 (9:31-9:32)\nfit!(resampler, MarketDataPoint(DateTime(2024, 1, 1, 9, 31, 0), 102.0, 1200.0))\n\nresult_before = value(resampler)\nprintln(\"Before: $(result_before.price.ohlc)\")  # OHLC(102.0, 102.0, 102.0, 102.0)\nprintln(\"Window: $(result_before.window.start_time)\")  # 2024-01-01T09:31:00\n\n# Now process OUT-OF-ORDER data from window 1\nfit!(resampler, MarketDataPoint(DateTime(2024, 1, 1, 9, 30, 45), 95.0, 1500.0))\n\nresult_after = value(resampler)\nprintln(\"After: $(result_after.price.ohlc)\")   # OHLC(95.0, 95.0, 95.0, 95.0)\nprintln(\"Window: $(result_after.window.start_time)\")   # 2024-01-01T09:30:00\n\n# ðŸš¨ ALL DATA FROM THE 9:31 WINDOW IS LOST!\n# ðŸš¨ The resampler moved back to the 9:30 window and reset everything!","category":"section"},{"location":"edge_cases/#Scenarios-and-Behaviors","page":"Edge Cases & Limitations","title":"Scenarios and Behaviors","text":"","category":"section"},{"location":"edge_cases/#1.-Within-Same-Window-(Usually-OK)","page":"Edge Cases & Limitations","title":"1. Within Same Window (Usually OK)","text":"resampler = MarketResampler(Minute(1))\n\n# Data arrives out of order but within same 1-minute window\nfit!(resampler, MarketDataPoint(DateTime(2024, 1, 1, 9, 30, 0), 100.0, 1000.0))   # First\nfit!(resampler, MarketDataPoint(DateTime(2024, 1, 1, 9, 30, 45), 105.0, 800.0))   # Last chronologically\nfit!(resampler, MarketDataPoint(DateTime(2024, 1, 1, 9, 30, 15), 95.0, 1200.0))   # Middle chronologically\n\nresult = value(resampler)\n# âœ… All data is preserved in OHLC\n# âŒ But Open=100.0 (first processed) and Close=95.0 (last processed)\n# âŒ Close is NOT the chronologically last price (105.0)!","category":"section"},{"location":"edge_cases/#2.-Across-Windows-(Always-Problematic)","page":"Edge Cases & Limitations","title":"2. Across Windows (Always Problematic)","text":"resampler = MarketResampler(Minute(1))\n\n# Process data in sequence: 9:30 â†’ 9:32 â†’ 9:31 â†’ 9:30\nfit!(resampler, MarketDataPoint(DateTime(2024, 1, 1, 9, 30, 0), 100.0, 1000.0))  # Window 1\nfit!(resampler, MarketDataPoint(DateTime(2024, 1, 1, 9, 32, 0), 110.0, 1500.0))  # Window 3\nfit!(resampler, MarketDataPoint(DateTime(2024, 1, 1, 9, 31, 0), 105.0, 800.0))   # Window 2\nfit!(resampler, MarketDataPoint(DateTime(2024, 1, 1, 9, 30, 30), 95.0, 1200.0))  # Back to Window 1\n\n# ðŸš¨ Only the last window (9:30) has data\n# ðŸš¨ All data from windows 9:32 and 9:31 is lost","category":"section"},{"location":"edge_cases/#Solutions","page":"Edge Cases & Limitations","title":"Solutions","text":"","category":"section"},{"location":"edge_cases/#Solution-1:-Pre-sort-Data","page":"Edge Cases & Limitations","title":"Solution 1: Pre-sort Data","text":"# Always sort your data before processing\nunsorted_data = [\n    MarketDataPoint(DateTime(2024, 1, 1, 9, 30, 45), 105.0, 800.0),\n    MarketDataPoint(DateTime(2024, 1, 1, 9, 30, 0), 100.0, 1000.0),\n    MarketDataPoint(DateTime(2024, 1, 1, 9, 30, 30), 102.0, 1200.0),\n]\n\n# Sort by timestamp\nsorted_data = sort(unsorted_data, by=x -> x.datetime)\n\nresampler = MarketResampler(Minute(1))\nfor data in sorted_data\n    fit!(resampler, data)\nend\n\nresult = value(resampler)\n# âœ… Correct OHLC with proper chronological order","category":"section"},{"location":"edge_cases/#Solution-2:-Batch-Processing-by-Windows","page":"Edge Cases & Limitations","title":"Solution 2: Batch Processing by Windows","text":"function batch_process_by_windows(data_points, period)\n    # Group data by time windows\n    windows = Dict{DateTime, Vector{MarketDataPoint}}()\n\n    for data in data_points\n        window_start = floor(data.datetime, period)\n        if !haskey(windows, window_start)\n            windows[window_start] = MarketDataPoint[]\n        end\n        push!(windows[window_start], data)\n    end\n\n    # Process each window with sorted data\n    results = []\n    for window_start in sort(collect(keys(windows)))\n        window_data = windows[window_start]\n        sorted_window_data = sort(window_data, by=x -> x.datetime)\n\n        window_resampler = MarketResampler(period)\n        for data in sorted_window_data\n            fit!(window_resampler, data)\n        end\n\n        result = value(window_resampler)\n        if result.price.ohlc !== nothing\n            push!(results, (\n                window_start = window_start,\n                ohlc = result.price.ohlc,\n                volume = result.volume\n            ))\n        end\n    end\n\n    return results\nend\n\n# Usage\nmixed_data = [/* your out-of-order data */]\nresults = batch_process_by_windows(mixed_data, Minute(1))","category":"section"},{"location":"edge_cases/#Solution-3:-Built-in-Chronological-Validation","page":"Edge Cases & Limitations","title":"Solution 3: Built-in Chronological Validation","text":"OnlineResamplers.jl now includes built-in validation to detect and prevent out-of-order data:\n\n# Enable chronological validation\nresampler = MarketResampler(Minute(1), validate_chronological=true)\n\n# Process data normally\nfit!(resampler, MarketDataPoint(DateTime(2024, 1, 1, 9, 30, 0), 100.0, 1000.0))\nfit!(resampler, MarketDataPoint(DateTime(2024, 1, 1, 9, 30, 30), 105.0, 800.0))\n\n# This will throw an ArgumentError with detailed message\ntry\n    fit!(resampler, MarketDataPoint(DateTime(2024, 1, 1, 9, 30, 15), 95.0, 1200.0))\ncatch e\n    println(\"Error: $(e.msg)\")\n    # Error: Data not in chronological order: 2024-01-01T09:30:15 < 2024-01-01T09:30:30.\n    # Received data point with timestamp 2024-01-01T09:30:15 but last processed timestamp was 2024-01-01T09:30:30.\n    # To disable this check, set validate_chronological=false in the constructor.\nend","category":"section"},{"location":"edge_cases/#Solution-4:-Manual-Validation","page":"Edge Cases & Limitations","title":"Solution 4: Manual Validation","text":"For cases where you want to validate before processing:\n\nfunction validate_chronological_order(data_points)\n    for i in 2:length(data_points)\n        if data_points[i].datetime < data_points[i-1].datetime\n            @warn \"Out-of-order data at index $i: $(data_points[i].datetime) < $(data_points[i-1].datetime)\"\n            return false\n        end\n    end\n    return true\nend\n\n# Always validate before processing\nif !validate_chronological_order(your_data)\n    @error \"Data is not in chronological order. Consider sorting first.\"\nend\n\n","category":"section"},{"location":"edge_cases/#Empty-Windows","page":"Edge Cases & Limitations","title":"Empty Windows","text":"OnlineResamplers handles empty windows gracefully, but you need to be aware of the behavior.","category":"section"},{"location":"edge_cases/#Behavior","page":"Edge Cases & Limitations","title":"Behavior","text":"resampler = MarketResampler(Minute(1))\n\n# No data processed yet\nresult = value(resampler)\nprintln(result.price.ohlc)  # nothing\nprintln(result.volume)      # 0.0\nprintln(result.window)      # nothing","category":"section"},{"location":"edge_cases/#After-Processing-Data","page":"Edge Cases & Limitations","title":"After Processing Data","text":"# Process one data point\nfit!(resampler, MarketDataPoint(DateTime(2024, 1, 1, 9, 30, 0), 100.0, 1000.0))\n\nresult = value(resampler)\nprintln(result.price.ohlc)  # OHLC(100.0, 100.0, 100.0, 100.0)\nprintln(result.window)      # TimeWindow{DateTime}(DateTime(\"2024-01-01T09:30:00\"), Minute(1))\n\n","category":"section"},{"location":"edge_cases/#Single-Data-Points","page":"Edge Cases & Limitations","title":"Single Data Points","text":"When only one data point exists in a window:\n\nresampler = MarketResampler(Minute(1))\nfit!(resampler, MarketDataPoint(DateTime(2024, 1, 1, 9, 30, 0), 100.0, 1000.0))\n\nresult = value(resampler)\nohlc = result.price.ohlc\n\n# All OHLC values are identical\n@assert ohlc.open == ohlc.high == ohlc.low == ohlc.close == 100.0\n\nThis is correct behavior - with only one price point, all OHLC values should be the same.\n\n","category":"section"},{"location":"edge_cases/#Type-Mismatches","page":"Edge Cases & Limitations","title":"Type Mismatches","text":"OnlineResamplers is strictly typed. Type mismatches will cause compile-time or runtime errors:\n\n# This will fail\nresampler = MarketResampler{DateTime, Float64, Float64}(Minute(1))\nbad_data = MarketDataPoint{DateTime, Int64, Float64}(DateTime(2024, 1, 1, 9, 30, 0), 100, 1000.0)\n\n# fit!(resampler, bad_data)  # MethodError: no method matching\n\n# Solution: Ensure consistent types\ngood_data = MarketDataPoint{DateTime, Float64, Float64}(DateTime(2024, 1, 1, 9, 30, 0), 100.0, 1000.0)\nfit!(resampler, good_data)  # Works","category":"section"},{"location":"edge_cases/#Type-Conversion-Helper","page":"Edge Cases & Limitations","title":"Type Conversion Helper","text":"function convert_market_data(data::MarketDataPoint, ::Type{T}, ::Type{P}, ::Type{V}) where {T,P,V}\n    return MarketDataPoint{T,P,V}(\n        T(data.datetime),\n        P(data.price),\n        V(data.volume)\n    )\nend\n\n# Usage\noriginal = MarketDataPoint(DateTime(2024, 1, 1, 9, 30, 0), 100, 1000)  # Int types\nconverted = convert_market_data(original, DateTime, Float64, Float64)\n\n","category":"section"},{"location":"edge_cases/#Very-Large-Time-Gaps","page":"Edge Cases & Limitations","title":"Very Large Time Gaps","text":"OnlineResamplers handles arbitrary time gaps, but be aware of implications:\n\nresampler = MarketResampler(Minute(1))\n\n# Process data at 9:30\nfit!(resampler, MarketDataPoint(DateTime(2024, 1, 1, 9, 30, 0), 100.0, 1000.0))\n\n# Process data much later (hours later)\nfit!(resampler, MarketDataPoint(DateTime(2024, 1, 1, 15, 30, 0), 200.0, 2000.0))\n\n# The resampler immediately moves to the 15:30 window\n# All intermediate windows (9:31, 9:32, ..., 15:29) are never created\nresult = value(resampler)\nprintln(result.window.start_time)  # 2024-01-01T15:30:00\n\nThis is expected behavior - OnlineResamplers doesn't create empty intermediate windows.\n\n","category":"section"},{"location":"edge_cases/#Precision-Issues","page":"Edge Cases & Limitations","title":"Precision Issues","text":"","category":"section"},{"location":"edge_cases/#With-Floating-Point-Types","page":"Edge Cases & Limitations","title":"With Floating Point Types","text":"# Floating point precision can affect comparisons\nresampler = MarketResampler(Microsecond(1))\n\ndt1 = DateTime(2024, 1, 1, 9, 30, 0) + Nanosecond(100)  # Not exactly representable\ndt2 = DateTime(2024, 1, 1, 9, 30, 0) + Nanosecond(200)\n\n# These might end up in the same microsecond window due to precision","category":"section"},{"location":"edge_cases/#Solution:-Use-Appropriate-Precision","page":"Edge Cases & Limitations","title":"Solution: Use Appropriate Precision","text":"using FixedPointDecimals\n\n# For high-precision financial data\nPreciseResampler = MarketResampler{DateTime, FixedDecimal{Int64,4}, FixedDecimal{Int64,2}}\nprecise_resampler = PreciseResampler(Minute(1))\n\nprecise_data = MarketDataPoint{DateTime, FixedDecimal{Int64,4}, FixedDecimal{Int64,2}}(\n    DateTime(2024, 1, 1, 9, 30, 0),\n    FixedDecimal{Int64,4}(100.1234),  # Exactly representable\n    FixedDecimal{Int64,2}(1000.50)    # Exactly representable\n)\n\nfit!(precise_resampler, precise_data)\n\n","category":"section"},{"location":"edge_cases/#Memory-Considerations","page":"Edge Cases & Limitations","title":"Memory Considerations","text":"","category":"section"},{"location":"edge_cases/#Normal-Operation-(Constant-Memory)","page":"Edge Cases & Limitations","title":"Normal Operation (Constant Memory)","text":"# Memory usage stays constant regardless of data volume\nresampler = MarketResampler(Minute(1))\n\nfor i in 1:1_000_000\n    timestamp = DateTime(2024, 1, 1, 9, 0, 0) + Millisecond(i)\n    data = MarketDataPoint(timestamp, 100.0, 1000.0)\n    fit!(resampler, data)\nend\n\n# Memory usage is O(1) - constant","category":"section"},{"location":"edge_cases/#Potential-Memory-Issues","page":"Edge Cases & Limitations","title":"Potential Memory Issues","text":"# DON'T store all intermediate results\nresults = []  # This will grow without bound!\nresampler = MarketResampler(Minute(1))\n\nfor data in huge_dataset\n    fit!(resampler, data)\n    push!(results, value(resampler))  # âŒ This defeats the purpose!\nend\n\nInstead, only store completed windows:\n\ncompleted_bars = []\nresampler = MarketResampler(Minute(1))\ncurrent_window = nothing\n\nfor data in huge_dataset\n    old_result = value(resampler)\n    old_window = old_result.window\n\n    fit!(resampler, data)\n\n    new_result = value(resampler)\n    if new_result.window != old_window && old_window !== nothing\n        # Window completed, save it\n        push!(completed_bars, (\n            timestamp = old_window.start_time,\n            ohlc = old_result.price.ohlc,\n            volume = old_result.volume\n        ))\n    end\nend\n\n","category":"section"},{"location":"edge_cases/#Best-Practices-for-Edge-Cases","page":"Edge Cases & Limitations","title":"Best Practices for Edge Cases","text":"","category":"section"},{"location":"edge_cases/#1.-Always-Validate-Input-Data","page":"Edge Cases & Limitations","title":"1. Always Validate Input Data","text":"function validate_market_data(data::MarketDataPoint)\n    if data.price <= 0\n        throw(ArgumentError(\"Price must be positive: $(data.price)\"))\n    end\n    if data.volume < 0\n        throw(ArgumentError(\"Volume cannot be negative: $(data.volume)\"))\n    end\n    return true\nend","category":"section"},{"location":"edge_cases/#2.-Sort-Before-Processing","page":"Edge Cases & Limitations","title":"2. Sort Before Processing","text":"function safe_resample(data_points, period; price_method=:ohlc)\n    # Always sort first\n    sorted_data = sort(data_points, by=x -> x.datetime)\n\n    resampler = MarketResampler(period, price_method=price_method)\n    for data in sorted_data\n        validate_market_data(data)\n        fit!(resampler, data)\n    end\n\n    return value(resampler)\nend","category":"section"},{"location":"edge_cases/#3.-Handle-Empty-Results","page":"Edge Cases & Limitations","title":"3. Handle Empty Results","text":"function safe_get_ohlc(resampler)\n    result = value(resampler)\n    if result.price.ohlc === nothing\n        @warn \"No OHLC data available - no data points processed yet\"\n        return nothing\n    end\n    return result.price.ohlc\nend","category":"section"},{"location":"edge_cases/#4.-Monitor-Window-Transitions","page":"Edge Cases & Limitations","title":"4. Monitor Window Transitions","text":"function process_with_monitoring(resampler, data_stream)\n    window_count = 0\n    current_window = nothing\n\n    for data in data_stream\n        old_result = value(resampler)\n        old_window = old_result.window\n\n        fit!(resampler, data)\n\n        new_result = value(resampler)\n        if new_result.window != old_window\n            window_count += 1\n            @info \"Window transition #$window_count: $(old_window) â†’ $(new_result.window)\"\n        end\n    end\n\n    return window_count\nend\n\n\n\nThese edge cases and limitations are important to understand when using OnlineResamplers.jl in production. The package is designed for streaming, chronologically-ordered data, and understanding these constraints will help you use it effectively.","category":"section"},{"location":"user_guide/#User-Guide","page":"User Guide","title":"User Guide","text":"This comprehensive guide covers all aspects of using OnlineResamplers.jl for financial market data processing.","category":"section"},{"location":"user_guide/#Table-of-Contents","page":"User Guide","title":"Table of Contents","text":"Installation\nCore Concepts\nBasic Usage\nAdvanced Features\nReal-World Examples\nPerformance Optimization\nIntegration with OnlineStats\nTroubleshooting\n\n","category":"section"},{"location":"user_guide/#Installation","page":"User Guide","title":"Installation","text":"using Pkg\nPkg.add(url=\"https://github.com/femtotrader/OnlineResamplers.jl\")","category":"section"},{"location":"user_guide/#Development-Installation","page":"User Guide","title":"Development Installation","text":"using Pkg\nPkg.develop(url=\"https://github.com/femtotrader/OnlineResamplers.jl\")\nPkg.test(\"OnlineResamplers\")\n\n","category":"section"},{"location":"user_guide/#Core-Concepts","page":"User Guide","title":"Core Concepts","text":"","category":"section"},{"location":"user_guide/#Market-Data-Structure","page":"User Guide","title":"Market Data Structure","text":"Market data is represented using the MarketDataPoint{T,P,V} structure, which provides type safety and flexibility:\n\nusing OnlineResamplers, Dates\n\n# Basic usage with default types (DateTime, Float64, Float64)\ndata = MarketDataPoint(DateTime(2024, 1, 1, 9, 30, 0), 100.50, 1000.0)\n\n# Explicit type construction\ndata_explicit = MarketDataPoint{DateTime, Float64, Float64}(\n    DateTime(2024, 1, 1, 9, 30, 0),\n    100.50,\n    1000.0\n)\n\n# Custom types for high precision\nusing FixedPointDecimals\nprecise_data = MarketDataPoint{DateTime, FixedDecimal{Int64,4}, FixedDecimal{Int64,2}}(\n    DateTime(2024, 1, 1, 9, 30, 0),\n    FixedDecimal{Int64,4}(100.5012),\n    FixedDecimal{Int64,2}(1000.50)\n)","category":"section"},{"location":"user_guide/#Time-Windows","page":"User Guide","title":"Time Windows","text":"Data is aggregated into time windows defined by start time and period. Understanding time windows is crucial for effective resampling:\n\nusing Dates\n\n# Create a 5-minute window\nwindow = TimeWindow{DateTime}(DateTime(2024, 1, 1, 9, 30, 0), Minute(5))\n\n# The window includes data from [start_time, start_time + period)\nprintln(\"Window start: $(window.start_time)\")      # 2024-01-01T09:30:00\nprintln(\"Window end: $(window_end(window))\")       # 2024-01-01T09:35:00\n\n# Check if timestamps belong to window\ntest_times = [\n    DateTime(2024, 1, 1, 9, 29, 59),  # Before window -> false\n    DateTime(2024, 1, 1, 9, 30, 0),   # Start of window -> true\n    DateTime(2024, 1, 1, 9, 32, 30),  # Middle of window -> true\n    DateTime(2024, 1, 1, 9, 35, 0)    # Next window -> false\n]\n\nfor ts in test_times\n    belongs = belongs_to_window(ts, window)\n    println(\"$(ts): $(belongs)\")\nend\n\n","category":"section"},{"location":"user_guide/#Basic-Usage","page":"User Guide","title":"Basic Usage","text":"","category":"section"},{"location":"user_guide/#OHLC-Resampling","page":"User Guide","title":"OHLC Resampling","text":"OHLC (Open, High, Low, Close) resampling is perfect for candlestick charts and technical analysis:\n\nusing OnlineResamplers, OnlineStatsBase, Dates\n\n# Create OHLC resampler (this is the default)\nohlc_resampler = MarketResampler(Minute(1), price_method=:ohlc)\n\n# Sample market data within one minute\nbase_time = DateTime(2024, 1, 1, 14, 30, 0)\nmarket_data = [\n    MarketDataPoint(base_time + Second(0), 100.00, 1000.0),   # Open\n    MarketDataPoint(base_time + Second(15), 102.50, 800.0),   # High point\n    MarketDataPoint(base_time + Second(30), 97.75, 1200.0),   # Low point\n    MarketDataPoint(base_time + Second(45), 101.25, 900.0)    # Close\n]\n\n# Process all data points\nfor data in market_data\n    fit!(ohlc_resampler, data)\nend\n\n# Extract results\nresult = value(ohlc_resampler)\nohlc = result.price.ohlc\n\nprintln(\"Open:  $(ohlc.open)\")     # 100.00 (first price)\nprintln(\"High:  $(ohlc.high)\")     # 102.50 (highest price)\nprintln(\"Low:   $(ohlc.low)\")      # 97.75  (lowest price)\nprintln(\"Close: $(ohlc.close)\")    # 101.25 (last price)\nprintln(\"Volume: $(result.volume)\") # 3900.0 (total volume)","category":"section"},{"location":"user_guide/#Mean-Price-Resampling","page":"User Guide","title":"Mean Price Resampling","text":"For applications requiring smoothed price data or when you need average prices over time intervals:\n\n# Create mean price resampler\nmean_resampler = MarketResampler(Minute(5), price_method=:mean)\n\n# Process the same data\nfor data in market_data\n    fit!(mean_resampler, data)\nend\n\nresult = value(mean_resampler)\nmean_price = result.price.mean_price\n\nprintln(\"Mean Price: $(mean_price)\")  # 100.375 ((100+102.5+97.75+101.25)/4)\nprintln(\"Volume: $(result.volume)\")   # 3900.0\n\n","category":"section"},{"location":"user_guide/#Advanced-Features","page":"User Guide","title":"Advanced Features","text":"","category":"section"},{"location":"user_guide/#Custom-Numeric-Types","page":"User Guide","title":"Custom Numeric Types","text":"OnlineResamplers fully supports custom numeric types commonly used in financial applications:\n\nusing FixedPointDecimals, NanoDates\n\n# Define high-precision types\nPriceType = FixedDecimal{Int128, 8}    # 8 decimal places for prices\nVolumeType = FixedDecimal{Int64, 2}    # 2 decimal places for volumes\n\n# Create high-precision resampler\nprecision_resampler = MarketResampler{NanoDate, PriceType, VolumeType}(\n    Nanosecond(1_000_000_000),  # 1 second intervals\n    price_method=:ohlc\n)\n\n# Create high-precision market data\nnano_data = MarketDataPoint{NanoDate, PriceType, VolumeType}(\n    NanoDate(2024, 1, 1, 9, 30, 0, 123456789),\n    PriceType(100.12345678),\n    VolumeType(1000.50)\n)\n\nfit!(precision_resampler, nano_data)\nresult = value(precision_resampler)\n\nprintln(\"High-precision OHLC: $(result.price.ohlc)\")\nprintln(\"High-precision Volume: $(result.volume)\")","category":"section"},{"location":"user_guide/#Parallel-Processing","page":"User Guide","title":"Parallel Processing","text":"OnlineResamplers supports efficient merging for parallel data processing:\n\n# Function to process a chunk of data\nfunction process_chunk(data_chunk::Vector, period::Period)\n    chunk_resampler = OHLCResampler{DateTime, Float64, Float64}(period)\n    for data in data_chunk\n        fit!(chunk_resampler, data)\n    end\n    return chunk_resampler\nend\n\n# Generate large dataset\nlarge_dataset = [\n    MarketDataPoint(DateTime(2024, 1, 1, 9, 0, i), 100.0 + sin(i/100), rand(500:1500))\n    for i in 1:10000\n]\n\n# Split into chunks for parallel processing\nchunk_size = 2500\nchunks = [large_dataset[i:min(i+chunk_size-1, end)] for i in 1:chunk_size:length(large_dataset)]\n\n# Process chunks (in real applications, use @distributed or threading)\nchunk_resamplers = [process_chunk(chunk, Minute(1)) for chunk in chunks]\n\n# Merge all results\nfinal_resampler = chunk_resamplers[1]\nfor i in 2:length(chunk_resamplers)\n    merge!(final_resampler, chunk_resamplers[i])\nend\n\nmerged_result = value(final_resampler)\nprintln(\"Merged OHLC: $(merged_result.ohlc)\")\nprintln(\"Total observations: $(nobs(final_resampler))\")","category":"section"},{"location":"user_guide/#Individual-Resamplers","page":"User Guide","title":"Individual Resamplers","text":"For specialized use cases, you can use individual resampler types directly:\n\n# Pure OHLC resampler\nohlc_only = OHLCResampler{DateTime, Float64, Float64}(Minute(1))\n\n# Mean price resampler\nmean_only = MeanResampler{DateTime, Float64, Float64}(Minute(5))\n\n# Sum resampler (for volume or other additive metrics)\nvolume_sum = SumResampler{DateTime, Float64, Float64}(Second(30))\n\n# Process sample data\nsample_data = MarketDataPoint(DateTime(2024, 1, 1, 10, 0, 0), 100.0, 1000.0)\n\nfit!(ohlc_only, sample_data)\nfit!(mean_only, sample_data)\nfit!(volume_sum, sample_data)\n\n# Get individual results\nohlc_result = value(ohlc_only)\nmean_result = value(mean_only)\nvolume_result = value(volume_sum)\n\nprintln(\"OHLC only: $(ohlc_result)\")\nprintln(\"Mean only: $(mean_result)\")\nprintln(\"Volume sum: $(volume_result)\")\n\n","category":"section"},{"location":"user_guide/#Real-World-Examples","page":"User Guide","title":"Real-World Examples","text":"","category":"section"},{"location":"user_guide/#Processing-CSV-Market-Data","page":"User Guide","title":"Processing CSV Market Data","text":"Here's a complete example processing market data from a CSV file:\n\nusing OnlineResamplers, OnlineStatsBase, Dates, CSV, DataFrames\n\n# Load tick data from CSV file\ntick_data = CSV.read(\"market_ticks.csv\", DataFrame)\n\n# Create 1-minute OHLC resampler\nresampler = MarketResampler(Minute(1))\n\n# Storage for completed OHLC bars\nohlc_bars = []\ncurrent_window = nothing\n\n# Process each tick\nfor row in eachrow(tick_data)\n    # Create market data point\n    data_point = MarketDataPoint(\n        DateTime(row.timestamp),\n        row.price,\n        row.volume\n    )\n\n    # Get current window before processing\n    old_window = value(resampler).window\n\n    # Process the data\n    fit!(resampler, data_point)\n\n    # Check if we moved to a new window (completed a bar)\n    new_result = value(resampler)\n    if new_result.window != old_window && old_window !== nothing\n        # We completed a window, save the OHLC bar\n        old_result = # You'll need to store this before processing new data\n        push!(ohlc_bars, (\n            timestamp = old_window.start_time,\n            open = old_result.price.ohlc.open,\n            high = old_result.price.ohlc.high,\n            low = old_result.price.ohlc.low,\n            close = old_result.price.ohlc.close,\n            volume = old_result.volume\n        ))\n    end\nend\n\n# Convert to DataFrame for analysis\nohlc_df = DataFrame(ohlc_bars)\nprintln(\"Generated $(nrow(ohlc_df)) OHLC bars from $(nrow(tick_data)) ticks\")\n\n# Save results\nCSV.write(\"ohlc_1min.csv\", ohlc_df)","category":"section"},{"location":"user_guide/#Multi-timeframe-Analysis","page":"User Guide","title":"Multi-timeframe Analysis","text":"Analyze the same data stream across multiple timeframes simultaneously:\n\n# Create resamplers for different timeframes\ntimeframes = Dict(\n    \"1min\" => MarketResampler(Minute(1)),\n    \"5min\" => MarketResampler(Minute(5)),\n    \"15min\" => MarketResampler(Minute(15)),\n    \"1hour\" => MarketResampler(Hour(1))\n)\n\n# Generate sample data (simulating 1 hour of minute-level ticks)\nbase_time = DateTime(2024, 1, 1, 9, 0, 0)\nsample_ticks = []\n\nprice = 100.0\nfor i in 1:60  # 60 minutes\n    # Add some realistic price movement\n    price += randn() * 0.1  # Random walk\n    volume = rand(500:1500)\n    timestamp = base_time + Minute(i)\n\n    push!(sample_ticks, MarketDataPoint(timestamp, price, volume))\nend\n\n# Process through all timeframes\nfor tick in sample_ticks\n    for (name, resampler) in timeframes\n        fit!(resampler, tick)\n    end\nend\n\n# Display results\nprintln(\"Multi-timeframe Analysis:\")\nprintln(\"========================\")\nfor (name, resampler) in sort(collect(timeframes))\n    result = value(resampler)\n    if result.price.ohlc !== nothing\n        ohlc = result.price.ohlc\n        @printf(\"%-8s: O=%6.2f H=%6.2f L=%6.2f C=%6.2f Vol=%8.0f\\\\n\",\n                name, ohlc.open, ohlc.high, ohlc.low, ohlc.close, result.volume)\n    end\nend\n\n","category":"section"},{"location":"user_guide/#Performance-Optimization","page":"User Guide","title":"Performance Optimization","text":"","category":"section"},{"location":"user_guide/#Memory-Efficiency","page":"User Guide","title":"Memory Efficiency","text":"OnlineResamplers uses constant memory regardless of data volume:\n\n# Memory usage stays constant even with millions of data points\nmemory_test_resampler = MarketResampler(Minute(1))\n\nprintln(\"Processing 1 million data points...\")\nfor i in 1:1_000_000\n    timestamp = DateTime(2024, 1, 1, 9, 0, 0) + Millisecond(i)\n    data = MarketDataPoint(timestamp, 100.0 + sin(i/1000), 1000.0)\n    fit!(memory_test_resampler, data)\n\n    # Memory usage remains constant due to automatic window transitions\nend\n\nresult = value(memory_test_resampler)\nprintln(\"Current window has $(nobs(memory_test_resampler)) observations\")\nprintln(\"Total memory usage is O(1) - constant regardless of data volume processed\")","category":"section"},{"location":"user_guide/#Type-Stability","page":"User Guide","title":"Type Stability","text":"For maximum performance, use concrete types and avoid type instabilities:\n\n# Good: Concrete types enable compiler optimizations\nfunction high_performance_processing(\n    resampler::MarketResampler{DateTime, Float64, Float64},\n    data_stream::Vector{MarketDataPoint{DateTime, Float64, Float64}}\n)\n    for data in data_stream\n        fit!(resampler, data)\n    end\n    return value(resampler)\nend\n\n# Usage\nfast_resampler = MarketResampler{DateTime, Float64, Float64}(Minute(1))\ntyped_data = MarketDataPoint{DateTime, Float64, Float64}[]\n\n# This will be highly optimized by the Julia compiler\nresult = high_performance_processing(fast_resampler, typed_data)","category":"section"},{"location":"user_guide/#Batch-Processing","page":"User Guide","title":"Batch Processing","text":"Process data in batches for optimal performance:\n\nfunction batch_process_ticks(resampler, ticks::Vector)\n    # Process all ticks without intermediate value() calls\n    for tick in ticks\n        fit!(resampler, tick)\n    end\n\n    # Get result only once at the end\n    return value(resampler)\nend\n\n# This approach is faster than calling value() after each fit!()\nbatch_resampler = MarketResampler(Minute(1))\nbatch_ticks = [\n    MarketDataPoint(DateTime(2024, 1, 1, 9, 30, i), 100.0 + randn(), 1000.0)\n    for i in 1:1000\n]\n\nresult = batch_process_ticks(batch_resampler, batch_ticks)","category":"section"},{"location":"user_guide/#Performance-Benchmarks","page":"User Guide","title":"Performance Benchmarks","text":"Here are typical performance characteristics:\n\nusing BenchmarkTools\n\n# Setup\nresampler = MarketResampler(Minute(1))\ndata = MarketDataPoint(DateTime(2024, 1, 1, 9, 30, 0), 100.0, 1000.0)\n\n# Single operation benchmark\n@benchmark fit!($resampler, $data)\n# Typical: ~50ns per operation\n\n# Batch processing benchmark\ndata_batch = [MarketDataPoint(DateTime(2024, 1, 1, 9, 30, i), rand(90:110), rand(500:1500)) for i in 1:10000]\nbatch_resampler = MarketResampler(Minute(1))\n\n@benchmark begin\n    for d in $data_batch\n        fit!($batch_resampler, d)\n    end\nend\n# Typical: ~500Î¼s for 10,000 operations (~50ns per operation)\n\nExpected performance characteristics:\n\nSingle operation: ~50 nanoseconds\nMemory usage: O(1) constant\nThroughput: >2 million operations/second on modern hardware\nMemory allocations: Zero in steady state\n\n","category":"section"},{"location":"user_guide/#Integration-with-OnlineStats","page":"User Guide","title":"Integration with OnlineStats","text":"OnlineResamplers seamlessly integrates with the broader OnlineStats ecosystem:\n\nusing OnlineStats\n\n# Combine market resampling with other online statistics\ncombined_stats = Group(\n    MarketResampler(Minute(1)),    # Market data resampling\n    Mean(),                        # Overall price mean\n    Variance(),                    # Price variance\n    CountMinSketch(String, 1000)   # Frequent symbols (if processing multiple assets)\n)\n\n# Generate sample data\ndata_stream = [\n    MarketDataPoint(DateTime(2024, 1, 1, 9, 30, i), 100.0 + randn(), 1000.0)\n    for i in 1:1000\n]\n\n# Process all statistics simultaneously\nfor data in data_stream\n    # The Group expects a tuple matching all statistics\n    fit!(combined_stats, (data, data.price, data.price))\nend\n\n# Access individual statistics\nresampler_result = value(combined_stats[1])  # MarketResampler results\nmean_price = value(combined_stats[2])        # Mean price\nprice_variance = value(combined_stats[3])    # Price variance\n\nprintln(\"OHLC: $(resampler_result.price.ohlc)\")\nprintln(\"Mean price: $(mean_price)\")\nprintln(\"Price variance: $(price_variance)\")","category":"section"},{"location":"user_guide/#Custom-OnlineStats-Integration","page":"User Guide","title":"Custom OnlineStats Integration","text":"You can also create custom statistics that work with market data:\n\nusing OnlineStatsBase\n\n# Custom statistic: Price range tracker\nmutable struct PriceRange <: OnlineStat{MarketDataPoint}\n    min_price::Float64\n    max_price::Float64\n    n::Int\n\n    PriceRange() = new(Inf, -Inf, 0)\nend\n\nfunction OnlineStatsBase._fit!(stat::PriceRange, data::MarketDataPoint)\n    stat.min_price = min(stat.min_price, data.price)\n    stat.max_price = max(stat.max_price, data.price)\n    stat.n += 1\n    return stat\nend\n\nfunction OnlineStatsBase.value(stat::PriceRange)\n    return (min=stat.min_price, max=stat.max_price, range=stat.max_price - stat.min_price)\nend\n\nOnlineStatsBase.nobs(stat::PriceRange) = stat.n\n\n# Usage\nprice_range = PriceRange()\nmarket_data = [MarketDataPoint(DateTime(2024, 1, 1, 9, 30, i), 100.0 + randn() * 5, 1000.0) for i in 1:100]\n\nfor data in market_data\n    fit!(price_range, data)\nend\n\nrange_result = value(price_range)\nprintln(\"Price range: $(range_result.min) to $(range_result.max)\")\nprintln(\"Total range: $(range_result.range)\")\n\n","category":"section"},{"location":"user_guide/#Troubleshooting","page":"User Guide","title":"Troubleshooting","text":"","category":"section"},{"location":"user_guide/#Common-Issues-and-Solutions","page":"User Guide","title":"Common Issues and Solutions","text":"","category":"section"},{"location":"user_guide/#Type-Mismatch-Errors","page":"User Guide","title":"Type Mismatch Errors","text":"# Problem: Type mismatch\nresampler = MarketResampler{DateTime, Float64, Float64}(Minute(1))\nbad_data = MarketDataPoint{DateTime, Int64, Float64}(DateTime(2024, 1, 1, 9, 30, 0), 100, 1000.0)\n\n# This will fail:\n# fit!(resampler, bad_data)  # ERROR: MethodError\n\n# Solution: Ensure consistent types\ngood_data = MarketDataPoint{DateTime, Float64, Float64}(DateTime(2024, 1, 1, 9, 30, 0), 100.0, 1000.0)\nfit!(resampler, good_data)  # Works fine","category":"section"},{"location":"user_guide/#Window-Alignment-Issues","page":"User Guide","title":"Window Alignment Issues","text":"# Problem: Unexpected window boundaries\nresampler = MarketResampler(Minute(1))\n\n# Data that doesn't align with minute boundaries\nmisaligned_data = MarketDataPoint(DateTime(2024, 1, 1, 9, 30, 37), 100.0, 1000.0)\nfit!(resampler, misaligned_data)\n\nresult = value(resampler)\nprintln(\"Window starts at: $(result.window.start_time)\")  # 2024-01-01T09:30:00\n\n# Solution: Understand that windows are floor-aligned\n# The window will start at 9:30:00 even though data arrived at 9:30:37","category":"section"},{"location":"user_guide/#Memory-Issues-with-Large-Datasets","page":"User Guide","title":"Memory Issues with Large Datasets","text":"# Problem: Processing very large datasets inefficiently\nfunction inefficient_processing(large_dataset)\n    results = []\n    resampler = MarketResampler(Minute(1))\n\n    for data in large_dataset\n        fit!(resampler, data)\n        push!(results, value(resampler))  # DON'T DO THIS - stores everything\n    end\n\n    return results\nend\n\n# Solution: Only store what you need\nfunction efficient_processing(large_dataset)\n    completed_bars = []\n    resampler = MarketResampler(Minute(1))\n    current_window = nothing\n\n    for data in large_dataset\n        old_result = value(resampler)\n        old_window = old_result.window\n\n        fit!(resampler, data)\n\n        new_result = value(resampler)\n        if new_result.window != old_window && old_window !== nothing\n            # Only store completed bars\n            push!(completed_bars, (\n                timestamp = old_window.start_time,\n                ohlc = old_result.price.ohlc,\n                volume = old_result.volume\n            ))\n        end\n    end\n\n    return completed_bars\nend","category":"section"},{"location":"user_guide/#Performance-Debugging","page":"User Guide","title":"Performance Debugging","text":"If you're experiencing performance issues:\n\nusing Profile\n\nfunction profile_resampling()\n    resampler = MarketResampler(Minute(1))\n    data_stream = [MarketDataPoint(DateTime(2024, 1, 1, 9, 30, i), 100.0, 1000.0) for i in 1:100000]\n\n    @profile begin\n        for data in data_stream\n            fit!(resampler, data)\n        end\n    end\nend\n\nprofile_resampling()\nProfile.print()  # Analyze where time is spent","category":"section"},{"location":"user_guide/#Validation-and-Testing","page":"User Guide","title":"Validation and Testing","text":"Always validate your results:\n\nfunction validate_ohlc(ohlc::OHLC)\n    @assert ohlc.high >= ohlc.open \"High should be >= Open\"\n    @assert ohlc.high >= ohlc.close \"High should be >= Close\"\n    @assert ohlc.low <= ohlc.open \"Low should be <= Open\"\n    @assert ohlc.low <= ohlc.close \"Low should be <= Close\"\n    @assert ohlc.high >= ohlc.low \"High should be >= Low\"\nend\n\n# Use in your processing pipeline\nresampler = MarketResampler(Minute(1))\n# ... process data ...\nresult = value(resampler)\n\nif result.price.ohlc !== nothing\n    validate_ohlc(result.price.ohlc)\n    println(\"OHLC validation passed âœ“\")\nend\n\n\n\nThis user guide covers the essential aspects of using OnlineResamplers.jl effectively. For more detailed API information, see the API Reference, and for step-by-step learning, check out the Tutorial.","category":"section"},{"location":"ai_transparency/#AI-Transparency-Documentation","page":"âš ï¸ AI Transparency","title":"AI Transparency Documentation","text":"âš ï¸ Important Notice: This document provides complete transparency about the use of AI tools in developing OnlineResamplers.jl. Please read this carefully before using the package in production environments.","category":"section"},{"location":"ai_transparency/#Executive-Summary","page":"âš ï¸ AI Transparency","title":"Executive Summary","text":"OnlineResamplers.jl was developed with significant AI assistance from Claude Sonnet 4.5 (Anthropic). While the package has been extensively tested and validated, users should understand the implications of AI-generated code and exercise appropriate due diligence.\n\nKey Facts:\n\n~60% of source code AI-assisted\n~90% of tests AI-generated\n~70% of documentation AI-generated\n94 BDD test scenarios, 100% passing\n90% code coverage\nFull EARS specification compliance\n\n","category":"section"},{"location":"ai_transparency/#1.-Generation-Method","page":"âš ï¸ AI Transparency","title":"1. Generation Method","text":"","category":"section"},{"location":"ai_transparency/#1.1-AI-Tool-Information","page":"âš ï¸ AI Transparency","title":"1.1 AI Tool Information","text":"Aspect Details\nTool Claude Code by Anthropic\nModel Claude Sonnet 4.5\nModel Version claude-sonnet-4-5-20250929\nKnowledge Cutoff January 2025\nGeneration Period September-October 2025\nMethodology Iterative development with human oversight","category":"section"},{"location":"ai_transparency/#1.2-Development-Approach","page":"âš ï¸ AI Transparency","title":"1.2 Development Approach","text":"The package was developed using an iterative, human-AI collaborative approach:\n\nHuman Specification â†’ Initial requirements and design\nAI Implementation â†’ Code generation based on specifications\nHuman Review â†’ Code review and refinement\nAI Testing â†’ Comprehensive test suite generation\nHuman Validation â†’ Testing and verification\nAI Documentation â†’ API docs and guides\nContinuous Iteration â†’ Refinement based on testing","category":"section"},{"location":"ai_transparency/#1.3-Scope-of-AI-Generated-Content","page":"âš ï¸ AI Transparency","title":"1.3 Scope of AI-Generated Content","text":"","category":"section"},{"location":"ai_transparency/#Source-Code-(src/OnlineResamplers.jl)-60%-AI-Assisted","page":"âš ï¸ AI Transparency","title":"Source Code (src/OnlineResamplers.jl) - ~60% AI-Assisted","text":"Fully AI-Generated Components:\n\nVolumeWindow type and implementation (~80 lines)\nTickWindow type and implementation (~40 lines)\nWindow state management helpers (~30 lines)\nGeneric window support refactoring (~100 lines)\nConvenience constructors (~50 lines)\n\nAI-Assisted (Human-Guided) Components:\n\nType parameter updates for window generics\nIntegration of new window types with existing resamplers\nDocumentation strings enhancements\n\nHuman-Written (AI-Reviewed) Components:\n\nCore OHLC aggregation logic\nTimeWindow implementation\nOriginal resampler types (OHLCResampler, MeanResampler, SumResampler)\nMarketDataPoint structure\nOnlineStatsBase interface implementation","category":"section"},{"location":"ai_transparency/#Tests-90%-AI-Generated","page":"âš ï¸ AI Transparency","title":"Tests - ~90% AI-Generated","text":"Fully AI-Generated:\n\ntest/test_bdd_specifications.jl (1,097 lines) - Complete BDD test suite\ntest/test_volume_resampler.jl (152 lines) - Volume window tests\nCustom BDD macros (@scenario, @given, @when, @then, @and_)\n\nHuman-Written:\n\ntest/test_resampler.jl - Original time-based tests\ntest/test_chronological_validation.jl - Original validation tests","category":"section"},{"location":"ai_transparency/#Documentation-70%-AI-Generated","page":"âš ï¸ AI Transparency","title":"Documentation - ~70% AI-Generated","text":"Fully AI-Generated:\n\nspecs/specs.md (766 lines) - EARS specification\nspecs/TEST_COVERAGE.md (254 lines) - Coverage matrix\nspecs/README.md (112 lines) - Specs documentation\ndocs/BUILD.md - Build documentation\nThis AI transparency page\nEnhanced API reference sections\n\nHuman-Written:\n\ndocs/src/index.md - Original homepage\ndocs/src/tutorial.md - Original tutorial\ndocs/src/user_guide.md - Original user guide\ndocs/src/edge_cases.md - Original limitations doc","category":"section"},{"location":"ai_transparency/#Examples-40%-AI-Generated","page":"âš ï¸ AI Transparency","title":"Examples - ~40% AI-Generated","text":"Fully AI-Generated:\n\nexamples/volume_based_resampling.jl (162 lines) - Volume bars example\n\nHuman-Written:\n\nexamples/usage_example.jl - Basic usage\nexamples/advanced_examples.jl - Advanced patterns\nexamples/out_of_order_data.jl - Error handling\n\n","category":"section"},{"location":"ai_transparency/#2.-Risk-Assessment","page":"âš ï¸ AI Transparency","title":"2. Risk Assessment","text":"","category":"section"},{"location":"ai_transparency/#2.1-Code-Quality-and-Correctness","page":"âš ï¸ AI Transparency","title":"2.1 Code Quality and Correctness","text":"Risk Level Details Mitigation\nLogic Errors Medium AI may introduce subtle bugs 94 test scenarios, human review\nEdge Cases Medium AI may miss uncommon scenarios Comprehensive test suite, real-world validation\nType Safety Low Strong Julia type system Type-stable implementations\nAPI Consistency Low AI follows patterns well OnlineStatsBase conventions\n\nSpecific Concerns:\n\nWindow boundary conditions in volume/tick-based resampling\nNumeric overflow/underflow with extreme values\nTimestamp edge cases (leap seconds, DST, etc.)\nConcurrent access patterns (not thread-safe by design)\n\nEvidence of Quality:\n\n94 BDD test scenarios, all passing\n90% code coverage\nType-stable implementations (verified)\nZero allocation in hot paths (benchmarked)","category":"section"},{"location":"ai_transparency/#2.2-Security-Considerations","page":"âš ï¸ AI Transparency","title":"2.2 Security Considerations","text":"Aspect Risk Level Details\nInput Validation Low Relies on Julia's type system\nExternal Dependencies Low Only OnlineStatsBase and Dates\nCode Injection None No eval or code generation\nData Leakage None No network/file I/O\nMemory Safety Low Pure Julia, managed memory\n\nSecurity Strengths:\n\nNo external network calls\nNo file system access\nNo code evaluation (eval, include)\nMinimal dependencies (OnlineStatsBase, Dates)\nImmutable data structures where appropriate\n\nPotential Vulnerabilities:\n\nDoS via infinite loops (mitigated: window-based processing)\nMemory exhaustion (mitigated: constant memory usage)\nNumeric overflow (user responsibility for type selection)","category":"section"},{"location":"ai_transparency/#2.3-Maintenance-and-Code-Understanding","page":"âš ï¸ AI Transparency","title":"2.3 Maintenance and Code Understanding","text":"Challenge Impact Mitigation\nCode Comprehension Medium AI code can be harder to understand\nDebugging Difficulty Medium Generated code may lack intuition\nKnowledge Transfer Medium Original developer context limited\nFuture Modifications Medium May be harder to extend\n\nMaintainability Features:\n\nComprehensive docstrings\nBDD tests serve as living documentation\nEARS specification provides design rationale\nClear separation of concerns\nFollows OnlineStatsBase patterns","category":"section"},{"location":"ai_transparency/#2.4-Edge-Case-Coverage","page":"âš ï¸ AI Transparency","title":"2.4 Edge Case Coverage","text":"Well-Covered:\n\nâœ… Empty data streams\nâœ… Single data point\nâœ… Window transitions\nâœ… Out-of-order data (with validation)\nâœ… Type conversions\nâœ… Zero/negative volumes\nâœ… Multiple window types\n\nPotentially Under-Tested:\n\nâš ï¸ Extreme numeric values (Inf, NaN)\nâš ï¸ Very large time spans (years)\nâš ï¸ High-frequency updates (microseconds)\nâš ï¸ Unusual timestamp types (custom calendars)\nâš ï¸ Thread safety (not designed for concurrency)","category":"section"},{"location":"ai_transparency/#2.5-Performance-Characteristics","page":"âš ï¸ AI Transparency","title":"2.5 Performance Characteristics","text":"Aspect Verified Method\nTime Complexity âœ… Yes Algorithm analysis\nMemory Usage âœ… Yes Constant memory per window\nType Stability âœ… Yes @code_warntype checks\nAllocations âœ… Yes @allocated benchmarks\nScaling âš ï¸ Partial Tested up to 1M data points\n\nPerformance Claims:\n\nO(1) per data point processing\nConstant memory usage\nZero allocations in steady state\nType-stable operations\n\nVerification Needed:\n\nProduction-scale workloads (billions of points)\nHigh-frequency tick data (microseconds)\nMemory pressure scenarios\nLong-running process stability","category":"section"},{"location":"ai_transparency/#2.6-API-Design-Consistency","page":"âš ï¸ AI Transparency","title":"2.6 API Design Consistency","text":"Criterion Assessment Details\nJulia Idioms âœ… Good Follows community standards\nOnlineStatsBase âœ… Excellent Full compliance\nNaming âœ… Good Clear, consistent\nType Hierarchy âœ… Good Proper use of abstract types\nDocumentation âœ… Excellent Comprehensive docstrings\n\nAPI Design Strengths:\n\nConsistent with OnlineStatsBase patterns\nClear type parameters\nIntuitive function names\nWell-documented\n\nPotential Concerns:\n\nGeneric window support adds complexity\nMultiple constructor variants may confuse users\nWindow interface requires careful implementation\n\n","category":"section"},{"location":"ai_transparency/#3.-Mitigation-Measures","page":"âš ï¸ AI Transparency","title":"3. Mitigation Measures","text":"","category":"section"},{"location":"ai_transparency/#3.1-Validation-Steps-Taken","page":"âš ï¸ AI Transparency","title":"3.1 Validation Steps Taken","text":"Code Validation:\n\nâœ… Comprehensive BDD test suite (94 scenarios)\nâœ… Human review of all AI-generated code\nâœ… Type stability verification\nâœ… Integration testing with OnlineStatsBase\nâœ… Example-driven validation\n\nTest Validation:\n\nâœ… All tests passing\nâœ… >90% code coverage\nâœ… BDD tests map to EARS requirements\nâœ… Edge cases explicitly tested\nâœ… Integration tests for realistic scenarios\n\nDocumentation Validation:\n\nâœ… Technical accuracy review\nâœ… Example code execution verification\nâœ… API documentation completeness\nâœ… Cross-reference validation","category":"section"},{"location":"ai_transparency/#3.2-Ongoing-Quality-Assurance","page":"âš ï¸ AI Transparency","title":"3.2 Ongoing Quality Assurance","text":"Continuous Integration:\n\nAutomated testing on every commit\nMultiple Julia versions (1.0+)\nMultiple platforms (Linux, macOS, Windows)\nCode coverage tracking\n\nCommunity Oversight:\n\nOpen source repository\nIssue tracking\nPull request reviews\nCommunity feedback incorporation\n\nVersion Control:\n\nGit history preserves all changes\nAI attribution in commits\nClear changelog\nSemantic versioning\n\n","category":"section"},{"location":"ai_transparency/#4.-User-Recommendations","page":"âš ï¸ AI Transparency","title":"4. User Recommendations","text":"","category":"section"},{"location":"ai_transparency/#4.1-For-All-Users","page":"âš ï¸ AI Transparency","title":"4.1 For All Users","text":"Before Using:\n\nRead the documentation thoroughly\nTutorial: Understanding basic concepts\nUser Guide: Best practices\nAPI Reference: Detailed function docs\nThis transparency page\nRun the test suite to verify compatibility\njulia --project=. -e 'using Pkg; Pkg.test()'\nReview the source code - It's only ~800 lines\nless src/OnlineResamplers.jl\nTest with your data - Validate behavior with realistic scenarios\n# Use your actual market data structure\nresampler = OHLCResampler(Minute(1))\nfor tick in your_data\n    data = MarketDataPoint(tick.time, tick.price, tick.volume)\n    fit!(resampler, data)\nend\nCheck the AI notice - Review AI_NOTICE.md","category":"section"},{"location":"ai_transparency/#4.2-For-Production-Users","page":"âš ï¸ AI Transparency","title":"4.2 For Production Users","text":"Enhanced Due Diligence Checklist:\n\n[ ] Security Audit\nReview code for security concerns specific to your environment\nValidate input handling for your data sources\nConsider numeric overflow scenarios\nAssess denial-of-service risks\n[ ] Extended Testing\nTest with production-like data volumes\nValidate edge cases from your domain\nStress test with extreme values\nTest error handling and recovery\nVerify performance under load\n[ ] Performance Benchmarking\nMeasure latency with your data\nProfile memory usage\nTest throughput requirements\nValidate real-time performance\n[ ] Expert Review\nHave experienced Julia developers review the code\nConsult domain experts (quantitative finance)\nConsider independent audit\n[ ] Monitoring and Validation\nImplement runtime validation\nMonitor for anomalies\nLog unusual values\nTrack performance metrics\n[ ] Gradual Rollout\nStart with non-critical systems\nShadow existing systems\nA/B test results\nMonitor closely","category":"section"},{"location":"ai_transparency/#4.3-For-Critical-Systems","page":"âš ï¸ AI Transparency","title":"4.3 For Critical Systems","text":"Additional Requirements:\n\n[ ] Independent Code Review\nMultiple expert reviewers\nLine-by-line analysis\nSecurity-focused review\n[ ] Formal Verification (if applicable)\nProve correctness of critical algorithms\nMathematical validation\nProperty-based testing\n[ ] Extensive Property-Based Testing\nQuickCheck-style testing\nInvariant verification\nFuzzing\n[ ] Production Data Testing\nFull-scale data volumes\nHistorical replay\nEdge case mining from production\n[ ] Disaster Recovery\nRollback plans\nData validation\nFailover strategies\n[ ] Regulatory Compliance\nDocument usage of AI tools\nValidate against regulations\nAudit trail","category":"section"},{"location":"ai_transparency/#4.4-For-Contributors","page":"âš ï¸ AI Transparency","title":"4.4 For Contributors","text":"Understanding AI-Generated Code:\n\nReview the BDD tests first - They explain behavior clearly\nRead the EARS specification - Understand requirements\nCheck test coverage matrix - See what's tested\nExamine examples - See realistic usage\n\nExtending the Package:\n\nStudy existing patterns (TimeWindow â†’ VolumeWindow â†’ TickWindow)\nWrite tests first (TDD approach)\nFollow the AbstractWindow interface\nMaintain type stability\nDocument thoroughly\n\nReporting Issues:\n\nWhen reporting issues related to AI-generated code:\n\nSpecify which component (use git blame)\nProvide minimal reproduction\nInclude expected vs actual behavior\nReference relevant tests if applicable\n\n","category":"section"},{"location":"ai_transparency/#5.-Transparency-Metrics","page":"âš ï¸ AI Transparency","title":"5. Transparency Metrics","text":"","category":"section"},{"location":"ai_transparency/#5.1-Quantitative-Data","page":"âš ï¸ AI Transparency","title":"5.1 Quantitative Data","text":"Code Metrics:\n\nSource LOC: ~800 lines (src/OnlineResamplers.jl)\nTest LOC: ~1,400 lines\nDocumentation LOC: ~5,000 lines\nExample LOC: ~600 lines\n\nTest Coverage:\n\nLine Coverage: >90%\nBranch Coverage: >85%\nTest Scenarios: 94 BDD scenarios\nTest Assertions: ~200+\n\nAI Generation Breakdown: | Component | AI % | Lines | Human Review | |â€“â€“â€“â€“â€“-|â€“â€“â€“|â€“â€“â€“-|â€“â€“â€“â€“â€“â€“â€“| | Core Logic | 30% | ~250 | âœ… Complete | | Window Types | 95% | ~200 | âœ… Complete | | Helpers | 80% | ~100 | âœ… Complete | | Tests | 90% | ~1,250 | âœ… Sampled | | Documentation | 70% | ~3,500 | âœ… Complete | | Examples | 40% | ~250 | âœ… Complete |","category":"section"},{"location":"ai_transparency/#5.2-Version-History","page":"âš ï¸ AI Transparency","title":"5.2 Version History","text":"Version Date AI Involvement Changes\n0.1.0 2025-09 40% Initial release (human-written)\n0.1.1 2025-10 60% Volume/tick windows, specs, BDD tests\n\n","category":"section"},{"location":"ai_transparency/#6.-Ethical-Commitment","page":"âš ï¸ AI Transparency","title":"6. Ethical Commitment","text":"The maintainers of OnlineResamplers.jl commit to:","category":"section"},{"location":"ai_transparency/#6.1-Transparency","page":"âš ï¸ AI Transparency","title":"6.1 Transparency","text":"âœ… Honest disclosure of AI involvement\nâœ… Clear attribution in git history\nâœ… Ongoing updates to this documentation\nâœ… Answering questions about AI usage","category":"section"},{"location":"ai_transparency/#6.2-Quality","page":"âš ï¸ AI Transparency","title":"6.2 Quality","text":"âœ… Rigorous testing and validation\nâœ… Human review of all AI-generated code\nâœ… Continuous improvement based on feedback\nâœ… Maintaining high code quality standards","category":"section"},{"location":"ai_transparency/#6.3-Support","page":"âš ï¸ AI Transparency","title":"6.3 Support","text":"âœ… Responsive bug fixes\nâœ… Clear issue reporting process\nâœ… Active maintenance\nâœ… Community engagement","category":"section"},{"location":"ai_transparency/#6.4-Accountability","page":"âš ï¸ AI Transparency","title":"6.4 Accountability","text":"âœ… Taking responsibility for all code (AI or human)\nâœ… Acknowledging and fixing issues promptly\nâœ… Learning from mistakes\nâœ… Improving processes","category":"section"},{"location":"ai_transparency/#6.5-Community","page":"âš ï¸ AI Transparency","title":"6.5 Community","text":"âœ… Welcoming contributions\nâœ… Clear contribution guidelines\nâœ… Respectful collaboration\nâœ… Knowledge sharing\n\n","category":"section"},{"location":"ai_transparency/#7.-Frequently-Asked-Questions","page":"âš ï¸ AI Transparency","title":"7. Frequently Asked Questions","text":"","category":"section"},{"location":"ai_transparency/#Q:-Is-it-safe-to-use-AI-generated-code?","page":"âš ï¸ AI Transparency","title":"Q: Is it safe to use AI-generated code?","text":"A: With appropriate validation, yes. This package has:\n\n94 passing test scenarios\n90% code coverage\nHuman review of all code\nComprehensive documentation\n\nHowever, you should still exercise due diligence appropriate to your use case.","category":"section"},{"location":"ai_transparency/#Q:-What-are-the-main-risks?","page":"âš ï¸ AI Transparency","title":"Q: What are the main risks?","text":"A: The primary risks are:\n\nSubtle edge cases not covered by tests\nMaintenance challenges (understanding AI code)\nPotential logic errors in complex scenarios\n\nThese are mitigated by testing, documentation, and human review.","category":"section"},{"location":"ai_transparency/#Q:-How-do-I-know-what's-AI-generated?","page":"âš ï¸ AI Transparency","title":"Q: How do I know what's AI-generated?","text":"A: Check:\n\nGit commit messages (AI-generated commits include attribution)\nThis documentation\nThe AI_NOTICE.md file","category":"section"},{"location":"ai_transparency/#Q:-Can-I-trust-the-test-suite?","page":"âš ï¸ AI Transparency","title":"Q: Can I trust the test suite?","text":"A: The test suite is comprehensive (94 scenarios) but also largely AI-generated. We recommend:\n\nRunning tests with your data\nAdding domain-specific tests\nValidating behavior in your context","category":"section"},{"location":"ai_transparency/#Q:-Should-I-use-this-in-production?","page":"âš ï¸ AI Transparency","title":"Q: Should I use this in production?","text":"A: That depends on:\n\nYour risk tolerance\nThe criticality of your system\nYour validation capabilities\n\nFollow the recommendations in Section 4.2-4.3 for guidance.","category":"section"},{"location":"ai_transparency/#Q:-Who-reviews-the-AI-generated-code?","page":"âš ï¸ AI Transparency","title":"Q: Who reviews the AI-generated code?","text":"A: All AI-generated code has been reviewed by the package maintainer. However, we encourage community review and welcome feedback.","category":"section"},{"location":"ai_transparency/#Q:-How-do-I-report-issues-with-AI-generated-code?","page":"âš ï¸ AI Transparency","title":"Q: How do I report issues with AI-generated code?","text":"A: Use the standard GitHub issue tracker: https://github.com/femtotrader/OnlineResamplers.jl/issues\n\nPlease mention if you suspect the issue relates to AI-generated components.","category":"section"},{"location":"ai_transparency/#Q:-Will-you-continue-using-AI?","page":"âš ï¸ AI Transparency","title":"Q: Will you continue using AI?","text":"A: Future development may involve AI assistance, always with:\n\nHuman oversight\nComprehensive testing\nClear attribution\nTransparent disclosure\n\n","category":"section"},{"location":"ai_transparency/#8.-Conclusion","page":"âš ï¸ AI Transparency","title":"8. Conclusion","text":"OnlineResamplers.jl demonstrates responsible use of AI in software development:\n\nClear transparency about AI involvement\nComprehensive testing and validation\nHuman review and oversight\nOngoing commitment to quality\n\nWhile AI-generated code requires appropriate scrutiny, this package has been developed with care and is suitable for many use cases. Users should exercise due diligence appropriate to their requirements.\n\nKey Takeaways:\n\nâœ… Significant AI involvement, fully disclosed\nâœ… Extensively tested and validated\nâœ… Human reviewed and maintained\nâœ… Suitable for many use cases with appropriate validation\nâš ï¸ Exercise due diligence for critical systems\n\n","category":"section"},{"location":"ai_transparency/#9.-Contact-and-Support","page":"âš ï¸ AI Transparency","title":"9. Contact and Support","text":"Questions about AI transparency?\n\nðŸ“§ Email: femto.trader@gmail.com\nðŸ› Issues: https://github.com/femtotrader/OnlineResamplers.jl/issues\nðŸ’¬ Discussions: https://github.com/femtotrader/OnlineResamplers.jl/discussions\n\nResources:\n\nAI Notice (Quick Reference)\nEARS Specification\nTest Coverage Matrix\nSource Code\n\n\n\nLast Updated: 2025-10-03 Document Version: 1.0 Package Version: 0.1.1 AI Tool: Claude Sonnet 4.5 (claude-sonnet-4-5-20250929)","category":"section"},{"location":"#OnlineResamplers.jl-Documentation","page":"Home","title":"OnlineResamplers.jl Documentation","text":"Welcome to the comprehensive documentation for OnlineResamplers.jl - a high-performance Julia package for real-time resampling of financial market data.\n\nwarning: AI-Generated Code Notice\nSignificant portions of this package were developed with AI assistance (Claude Sonnet 4.5).While extensively tested (>90% coverage, 94 BDD scenarios), users should exercise appropriate due diligence for production use.ðŸ“‹ Read Full AI Transparency Documentation â†’ | ðŸ“„ Quick Reference (AI_NOTICE.md) â†’","category":"section"},{"location":"#Documentation-Overview","page":"Home","title":"Documentation Overview","text":"","category":"section"},{"location":"#Getting-Started","page":"Home","title":"ðŸ“š Getting Started","text":"Tutorial - Step-by-step guide from basic concepts to advanced usage\nInstallation and setup\nCore concepts (MarketDataPoint, TimeWindow, OHLC)\nBasic resampling strategies\nReal-time processing patterns\nPerformance optimization tips","category":"section"},{"location":"#Comprehensive-Reference","page":"Home","title":"ðŸ“– Comprehensive Reference","text":"User Guide - Complete guide with detailed examples and best practices\nInstallation options\nCore concepts and data structures\nBasic and advanced usage patterns\nReal-world examples (CSV processing, multi-timeframe analysis)\nPerformance optimization strategies\nOnlineStats integration\nTroubleshooting and debugging\nAPI Reference - Detailed technical documentation\nComplete function signatures and parameters\nType specifications and compatibility\nReturn value documentation\nPerformance characteristics\nUsage examples for each function\nEdge Cases & Limitations - Important behaviors and gotchas\nOut-of-order data handling\nEmpty windows and single data points\nType mismatch issues\nMemory considerations\nBest practices for edge cases","category":"section"},{"location":"#Examples-and-Patterns","page":"Home","title":"ðŸ’¡ Examples and Patterns","text":"Advanced Examples - Complex real-world scenarios\nusage_example.jl - Basic usage patterns\nadvanced_examples.jl - Complex scenarios including:\nMulti-timeframe analysis\nHigh-precision calculations\nReal-time streaming\nParallel processing\nPerformance demonstrations\nout_of_order_data.jl - Handling non-chronological data","category":"section"},{"location":"#Tests","page":"Home","title":"ðŸ§ª Tests","text":"Test Suite - Comprehensive test coverage\ntest_resampler.jl - Core functionality tests\n\n","category":"section"},{"location":"#Quick-Navigation","page":"Home","title":"Quick Navigation","text":"","category":"section"},{"location":"#By-Use-Case","page":"Home","title":"By Use Case","text":"Use Case Documentation Examples\nGetting Started Tutorial - Getting Started Basic Usage\nOHLC Candlesticks User Guide - OHLC OHLC Examples\nHigh-Precision Data Tutorial - Custom Types Precision Examples\nReal-time Processing Tutorial - Real-time Streaming Examples\nPerformance Optimization User Guide - Performance Benchmarks\nParallel Processing Tutorial - Parallel Merge Examples\nOut-of-Order Data Edge Cases - Out-of-Order Out-of-Order Examples","category":"section"},{"location":"#By-Experience-Level","page":"Home","title":"By Experience Level","text":"Level Start Here Then Read Finally Try\nBeginner Tutorial User Guide - Basic Usage Basic Examples\nIntermediate User Guide API Reference Advanced Examples\nExpert API Reference Source Code Custom implementations","category":"section"},{"location":"#By-Topic","page":"Home","title":"By Topic","text":"","category":"section"},{"location":"#Core-Concepts","page":"Home","title":"Core Concepts","text":"MarketDataPoint Structure\nTime Windows\nOHLC Data Format\nOnlineStatsBase Integration","category":"section"},{"location":"#Resampling-Methods","page":"Home","title":"Resampling Methods","text":"OHLC Resampling - Candlestick aggregation\nMean Price Resampling - Average price calculation\nVolume Sum Resampling - Volume aggregation","category":"section"},{"location":"#Advanced-Features","page":"Home","title":"Advanced Features","text":"Chronological Validation - Built-in out-of-order data detection\nCustom Numeric Types\nParallel Processing\nMulti-timeframe Analysis\nPerformance Optimization","category":"section"},{"location":"#Integration","page":"Home","title":"Integration","text":"OnlineStats Ecosystem\nCSV Data Processing\nReal-time Data Streams\n\n","category":"section"},{"location":"#Package-Architecture","page":"Home","title":"Package Architecture","text":"OnlineResamplers.jl is built on a clean, extensible architecture:\n\nOnlineResamplers.jl\nâ”œâ”€â”€ Core Types\nâ”‚   â”œâ”€â”€ MarketDataPoint{T,P,V}      # Input data structure\nâ”‚   â”œâ”€â”€ OHLC{P}                     # Price aggregation result\nâ”‚   â””â”€â”€ TimeWindow{T}               # Time interval definition\nâ”œâ”€â”€ Abstract Types\nâ”‚   â””â”€â”€ AbstractResampler{T,P,V}    # Base for all resamplers\nâ”œâ”€â”€ Concrete Resamplers\nâ”‚   â”œâ”€â”€ OHLCResampler{T,P,V}        # OHLC price aggregation\nâ”‚   â”œâ”€â”€ MeanResampler{T,P,V}        # Mean price aggregation\nâ”‚   â”œâ”€â”€ SumResampler{T,P,V}         # Sum aggregation (volumes)\nâ”‚   â””â”€â”€ MarketResampler{T,P,V}      # Composite resampler\nâ””â”€â”€ OnlineStatsBase Integration\n    â”œâ”€â”€ fit!(resampler, data)       # Process data\n    â”œâ”€â”€ value(resampler)            # Get results\n    â”œâ”€â”€ nobs(resampler)             # Count observations\n    â””â”€â”€ merge!(r1, r2)              # Combine resamplers","category":"section"},{"location":"#Type-System","page":"Home","title":"Type System","text":"The package uses a comprehensive parametric type system:\n\nT: Timestamp type (DateTime, NanoDate, ZonedDateTime, etc.)\nP: Price type (Float64, FixedDecimal, Rational, etc.)\nV: Volume type (Float64, FixedDecimal, Int64, etc.)\n\nThis design enables:\n\nType Safety: Compile-time type checking prevents runtime errors\nPerformance: Type-stable operations for maximum speed\nFlexibility: Support for any numeric type with appropriate operations\nPrecision: Use exact arithmetic types for financial calculations","category":"section"},{"location":"#Performance-Characteristics","page":"Home","title":"Performance Characteristics","text":"OnlineResamplers.jl is designed for high-performance applications:\n\nMemory: O(1) constant memory usage regardless of data volume\nSpeed: ~50 nanoseconds per operation on modern hardware\nThroughput: >2 million operations per second\nAllocations: Zero allocations in steady-state processing\nScalability: Supports parallel processing with merge operations","category":"section"},{"location":"#Contributing","page":"Home","title":"Contributing","text":"We welcome contributions! Areas where help is especially appreciated:\n\nNew Resampling Methods: Implement additional aggregation strategies\nPerformance Improvements: Optimize hot code paths\nDocumentation: Improve examples and explanations\nTesting: Add test cases for edge conditions\nIntegration: Examples with other Julia packages\n\nSee the source code and test files for implementation examples.\n\n","category":"section"},{"location":"#Support-and-Community","page":"Home","title":"Support and Community","text":"Issues: Report bugs and request features on GitHub Issues\nDiscussions: Ask questions on GitHub Discussions\nDocumentation: Contribute improvements to help others learn\n\n\n\nThis documentation covers OnlineResamplers.jl v0.1.0 and later. For earlier versions, please refer to the appropriate git tags.","category":"section"},{"location":"tutorial/#OnlineResamplers.jl-Tutorial","page":"Tutorial","title":"OnlineResamplers.jl Tutorial","text":"This tutorial will guide you through the main features of OnlineResamplers.jl, from basic usage to advanced applications.","category":"section"},{"location":"tutorial/#Table-of-Contents","page":"Tutorial","title":"Table of Contents","text":"Getting Started\nBasic Resampling\nUnderstanding Time Windows\nWorking with Different Data Types\nAdvanced Resampling Strategies\nReal-time Data Processing\nPerformance Optimization\nBest Practices\n\n","category":"section"},{"location":"tutorial/#Getting-Started","page":"Tutorial","title":"Getting Started","text":"","category":"section"},{"location":"tutorial/#Installation","page":"Tutorial","title":"Installation","text":"using Pkg\nPkg.add(url=\"https://github.com/femtotrader/OnlineResamplers.jl\")","category":"section"},{"location":"tutorial/#Basic-Setup","page":"Tutorial","title":"Basic Setup","text":"using OnlineResamplers, OnlineStatsBase, Dates","category":"section"},{"location":"tutorial/#Your-First-Resampler","page":"Tutorial","title":"Your First Resampler","text":"# Create a simple 1-minute OHLC resampler\nresampler = MarketResampler(Minute(1))\n\n# Create some sample market data\ndata1 = MarketDataPoint(DateTime(2024, 1, 1, 9, 30, 0), 100.0, 1000.0)\ndata2 = MarketDataPoint(DateTime(2024, 1, 1, 9, 30, 30), 105.0, 800.0)\ndata3 = MarketDataPoint(DateTime(2024, 1, 1, 9, 30, 45), 98.0, 1200.0)\n\n# Process the data\nfit!(resampler, data1)\nfit!(resampler, data2)\nfit!(resampler, data3)\n\n# Get the results\nresult = value(resampler)\nprintln(\"OHLC: $(result.price.ohlc)\")\nprintln(\"Volume: $(result.volume)\")\n\nOutput:\n\nOHLC: OHLC(100.0, 105.0, 98.0, 98.0)\nVolume: 3000.0\n\n","category":"section"},{"location":"tutorial/#Basic-Resampling","page":"Tutorial","title":"Basic Resampling","text":"","category":"section"},{"location":"tutorial/#OHLC-(Open,-High,-Low,-Close)-Resampling","page":"Tutorial","title":"OHLC (Open, High, Low, Close) Resampling","text":"OHLC resampling is the most common way to aggregate tick data into candlestick charts:\n\n# Create OHLC resampler (this is the default)\nohlc_resampler = MarketResampler(Minute(1), price_method=:ohlc)\n\n# Sample tick data within one minute\nbase_time = DateTime(2024, 1, 1, 14, 30, 0)\nticks = [\n    MarketDataPoint(base_time + Second(0), 100.00, 1000.0),   # Open\n    MarketDataPoint(base_time + Second(15), 102.50, 800.0),   # High\n    MarketDataPoint(base_time + Second(30), 97.75, 1200.0),   # Low\n    MarketDataPoint(base_time + Second(45), 101.25, 900.0)    # Close\n]\n\n# Process all ticks\nfor tick in ticks\n    fit!(ohlc_resampler, tick)\nend\n\nresult = value(ohlc_resampler)\nohlc = result.price.ohlc\n\nprintln(\"Open:  $(ohlc.open)\")     # 100.00 (first price)\nprintln(\"High:  $(ohlc.high)\")     # 102.50 (highest price)\nprintln(\"Low:   $(ohlc.low)\")      # 97.75  (lowest price)\nprintln(\"Close: $(ohlc.close)\")    # 101.25 (last price)\nprintln(\"Volume: $(result.volume)\") # 3900.0 (total volume)","category":"section"},{"location":"tutorial/#Mean-Price-Resampling","page":"Tutorial","title":"Mean Price Resampling","text":"For applications requiring smoothed price data:\n\n# Create mean price resampler\nmean_resampler = MarketResampler(Minute(5), price_method=:mean)\n\n# Process the same data\nfor tick in ticks\n    fit!(mean_resampler, tick)\nend\n\nresult = value(mean_resampler)\nmean_price = result.price.mean_price\n\nprintln(\"Mean Price: $(mean_price)\")  # 100.375 ((100+102.5+97.75+101.25)/4)\nprintln(\"Volume: $(result.volume)\")   # 3900.0","category":"section"},{"location":"tutorial/#Chronological-Data-Validation","page":"Tutorial","title":"Chronological Data Validation","text":"OnlineResamplers is designed for streaming data and assumes chronological order. You can enable validation to detect and prevent out-of-order data:","category":"section"},{"location":"tutorial/#Default-Behavior-(No-Validation)","page":"Tutorial","title":"Default Behavior (No Validation)","text":"# By default, validation is disabled for performance\nresampler = MarketResampler(Minute(1))  # validate_chronological=false by default\n\n# This allows out-of-order data but may cause unexpected behavior\nfit!(resampler, MarketDataPoint(DateTime(2024, 1, 1, 9, 30, 0), 100.0, 1000.0))\nfit!(resampler, MarketDataPoint(DateTime(2024, 1, 1, 9, 29, 0), 99.0, 800.0))   # Out of order!","category":"section"},{"location":"tutorial/#Enabled-Validation","page":"Tutorial","title":"Enabled Validation","text":"# Enable chronological validation\nvalidated_resampler = MarketResampler(Minute(1), validate_chronological=true)\n\n# Process data chronologically - this works fine\nfit!(validated_resampler, MarketDataPoint(DateTime(2024, 1, 1, 9, 30, 0), 100.0, 1000.0))\nfit!(validated_resampler, MarketDataPoint(DateTime(2024, 1, 1, 9, 30, 30), 105.0, 800.0))\n\n# This will throw an ArgumentError with detailed message\ntry\n    fit!(validated_resampler, MarketDataPoint(DateTime(2024, 1, 1, 9, 30, 15), 95.0, 1200.0))\ncatch e\n    println(\"Error: Out-of-order data detected!\")\n    # ArgumentError: Data not in chronological order: 2024-01-01T09:30:15 <= 2024-01-01T09:30:30\nend\n\nWhen to use validation:\n\nâœ… When processing historical data that might be unsorted\nâœ… When debugging data quality issues\nâœ… When data integrity is critical\nâŒ High-frequency real-time streams (performance impact)\nâŒ When you're certain data is already chronologically ordered\n\n","category":"section"},{"location":"tutorial/#Understanding-Time-Windows","page":"Tutorial","title":"Understanding Time Windows","text":"Time windows are fundamental to how OnlineResamplers groups data:","category":"section"},{"location":"tutorial/#How-Time-Windows-Work","page":"Tutorial","title":"How Time Windows Work","text":"using Dates\n\n# Create a 1-minute window starting at 9:30 AM\nwindow = TimeWindow{DateTime}(DateTime(2024, 1, 1, 9, 30, 0), Minute(1))\n\n# The window covers [9:30:00, 9:31:00)\nprintln(\"Window start: $(window.start_time)\")          # 2024-01-01T09:30:00\nprintln(\"Window end: $(window_end(window))\")           # 2024-01-01T09:31:00\n\n# Test timestamps\ntimestamps = [\n    DateTime(2024, 1, 1, 9, 29, 59),  # Before window\n    DateTime(2024, 1, 1, 9, 30, 0),   # Start of window\n    DateTime(2024, 1, 1, 9, 30, 30),  # Middle of window\n    DateTime(2024, 1, 1, 9, 31, 0)    # Start of next window\n]\n\nfor ts in timestamps\n    belongs = belongs_to_window(ts, window)\n    println(\"$(ts): $(belongs)\")\nend\n\nOutput:\n\n2024-01-01T09:29:59: false\n2024-01-01T09:30:00: true\n2024-01-01T09:30:30: true\n2024-01-01T09:31:00: false","category":"section"},{"location":"tutorial/#Window-Transitions","page":"Tutorial","title":"Window Transitions","text":"Resamplers automatically handle window transitions:\n\nresampler = MarketResampler(Minute(1))\n\n# First window data\ndata1 = MarketDataPoint(DateTime(2024, 1, 1, 9, 30, 0), 100.0, 1000.0)\ndata2 = MarketDataPoint(DateTime(2024, 1, 1, 9, 30, 30), 105.0, 800.0)\n\n# Second window data (next minute)\ndata3 = MarketDataPoint(DateTime(2024, 1, 1, 9, 31, 0), 110.0, 1200.0)\ndata4 = MarketDataPoint(DateTime(2024, 1, 1, 9, 31, 30), 108.0, 900.0)\n\n# Process first window\nfit!(resampler, data1)\nfit!(resampler, data2)\nresult1 = value(resampler)\nprintln(\"First window OHLC: $(result1.price.ohlc)\")\nprintln(\"Window: $(result1.window.start_time)\")\n\n# Process second window - resampler automatically resets\nfit!(resampler, data3)\nfit!(resampler, data4)\nresult2 = value(resampler)\nprintln(\"Second window OHLC: $(result2.price.ohlc)\")\nprintln(\"Window: $(result2.window.start_time)\")\n\n","category":"section"},{"location":"tutorial/#Working-with-Different-Data-Types","page":"Tutorial","title":"Working with Different Data Types","text":"","category":"section"},{"location":"tutorial/#High-Precision-Financial-Data","page":"Tutorial","title":"High-Precision Financial Data","text":"OnlineResamplers supports custom numeric types for high-precision calculations:\n\n# Using Rational numbers for exact arithmetic\nPrecisePrice = Rational{Int128}\nPreciseVolume = Rational{Int64}\n\n# Create high-precision resampler\nprecise_resampler = MarketResampler{DateTime, PrecisePrice, PreciseVolume}(\n    Minute(1), price_method=:ohlc\n)\n\n# High-precision data\nprecise_data = MarketDataPoint{DateTime, PrecisePrice, PreciseVolume}(\n    DateTime(2024, 1, 1, 9, 30, 0),\n    PrecisePrice(1001234, 10000),  # 100.1234 exactly\n    PreciseVolume(10005, 10)       # 1000.5 exactly\n)\n\nfit!(precise_resampler, precise_data)\nresult = value(precise_resampler)\n\nprintln(\"Precise OHLC: $(result.price.ohlc)\")\nprintln(\"Precise Volume: $(result.volume)\")","category":"section"},{"location":"tutorial/#Custom-Time-Types","page":"Tutorial","title":"Custom Time Types","text":"# Example with custom time handling (conceptual)\n# In practice, you'd use libraries like NanoDates.jl or TimeZones.jl\n\n# Standard DateTime usage\ndatetime_resampler = MarketResampler{DateTime, Float64, Float64}(Minute(1))\n\n# The resampler will work with any type T that supports:\n# - T + Period -> T (arithmetic)\n# - T comparison operators\n# - floor(T, Period) -> T (for window alignment)\n\n","category":"section"},{"location":"tutorial/#Advanced-Resampling-Strategies","page":"Tutorial","title":"Advanced Resampling Strategies","text":"","category":"section"},{"location":"tutorial/#Individual-Resamplers","page":"Tutorial","title":"Individual Resamplers","text":"For specialized use cases, you can use individual resampler types:\n\n# Pure OHLC resampler\nohlc_only = OHLCResampler(Minute(1))\n\n# Mean price resampler\nmean_only = MeanResampler(Minute(5))\n\n# Volume sum resampler\nvolume_sum = SumResampler(Second(30))\n\n# Process data\nsample_data = MarketDataPoint(DateTime(2024, 1, 1, 10, 0, 0), 100.0, 1000.0)\n\nfit!(ohlc_only, sample_data)\nfit!(mean_only, sample_data)\nfit!(volume_sum, sample_data)\n\n# Get individual results\nohlc_result = value(ohlc_only)\nmean_result = value(mean_only)\nvolume_result = value(volume_sum)\n\nprintln(\"OHLC only: $(ohlc_result)\")\nprintln(\"Mean only: $(mean_result)\")\nprintln(\"Volume sum: $(volume_result)\")","category":"section"},{"location":"tutorial/#Multi-timeframe-Analysis","page":"Tutorial","title":"Multi-timeframe Analysis","text":"Analyze the same data stream across multiple timeframes:\n\n# Create resamplers for different timeframes\ntimeframes = Dict(\n    \"1min\" => MarketResampler(Minute(1)),\n    \"5min\" => MarketResampler(Minute(5)),\n    \"15min\" => MarketResampler(Minute(15)),\n    \"1hour\" => MarketResampler(Hour(1))\n)\n\n# Generate sample data\nbase_time = DateTime(2024, 1, 1, 9, 0, 0)\nsample_ticks = [\n    MarketDataPoint(base_time + Minute(i), 100.0 + randn(), rand(500:1500))\n    for i in 1:60  # 1 hour of minute-level data\n]\n\n# Process through all timeframes\nfor tick in sample_ticks\n    for (name, resampler) in timeframes\n        fit!(resampler, tick)\n    end\nend\n\n# Display results\nprintln(\"Multi-timeframe Analysis:\")\nfor (name, resampler) in sort(collect(timeframes))\n    result = value(resampler)\n    if result.price.ohlc !== nothing\n        ohlc = result.price.ohlc\n        println(\"$name: O=$(round(ohlc.open, digits=2)), \" *\n                \"H=$(round(ohlc.high, digits=2)), \" *\n                \"L=$(round(ohlc.low, digits=2)), \" *\n                \"C=$(round(ohlc.close, digits=2)), \" *\n                \"Vol=$(round(result.volume))\")\n    end\nend\n\n","category":"section"},{"location":"tutorial/#Real-time-Data-Processing","page":"Tutorial","title":"Real-time Data Processing","text":"","category":"section"},{"location":"tutorial/#Stream-Processing-with-Window-Detection","page":"Tutorial","title":"Stream Processing with Window Detection","text":"For real-time applications, you often need to detect when windows complete:\n\nmutable struct RealTimeProcessor\n    resampler::MarketResampler\n    completed_bars::Vector{NamedTuple}\n    current_window::Union{TimeWindow, Nothing}\nend\n\nfunction RealTimeProcessor(period::Period)\n    RealTimeProcessor(\n        MarketResampler(period),\n        NamedTuple[],\n        nothing\n    )\nend\n\nfunction process_tick!(processor::RealTimeProcessor, tick::MarketDataPoint)\n    # Get current state before processing\n    old_result = value(processor.resampler)\n    old_window = old_result.window\n\n    # Process the tick\n    fit!(processor.resampler, tick)\n\n    # Check for window completion\n    new_result = value(processor.resampler)\n    new_window = new_result.window\n\n    if old_window !== nothing && new_window != old_window\n        # Window completed! Save the bar\n        if old_result.price.ohlc !== nothing\n            completed_bar = (\n                timestamp = old_window.start_time,\n                open = old_result.price.ohlc.open,\n                high = old_result.price.ohlc.high,\n                low = old_result.price.ohlc.low,\n                close = old_result.price.ohlc.close,\n                volume = old_result.volume\n            )\n            push!(processor.completed_bars, completed_bar)\n\n            # Callback for completed bar\n            on_bar_complete(completed_bar)\n        end\n    end\n\n    processor.current_window = new_window\nend\n\nfunction on_bar_complete(bar)\n    println(\"âœ… Bar completed: $(bar.timestamp) - \" *\n            \"OHLC($(bar.open), $(bar.high), $(bar.low), $(bar.close)) \" *\n            \"Vol: $(bar.volume)\")\nend\n\n# Usage example\nprocessor = RealTimeProcessor(Minute(1))\n\n# Simulate real-time tick stream\nstream_base = DateTime(2024, 1, 1, 14, 30, 0)\nfor minute in 0:2, second in [0, 30]\n    timestamp = stream_base + Minute(minute) + Second(second)\n    tick = MarketDataPoint(timestamp, 100.0 + minute + randn()*0.1, rand(800:1200))\n    process_tick!(processor, tick)\nend","category":"section"},{"location":"tutorial/#Parallel-Processing","page":"Tutorial","title":"Parallel Processing","text":"For high-throughput applications, process data in parallel and merge results:\n\n# Function to process a chunk of data\nfunction process_chunk(data_chunk::Vector, period::Period)\n    chunk_resampler = OHLCResampler{DateTime, Float64, Float64}(period)\n    for data in data_chunk\n        fit!(chunk_resampler, data)\n    end\n    return chunk_resampler\nend\n\n# Generate large dataset\nlarge_dataset = [\n    MarketDataPoint(DateTime(2024, 1, 1, 9, 0, i), 100.0 + sin(i/100), rand(500:1500))\n    for i in 1:10000\n]\n\n# Split into chunks for parallel processing\nchunk_size = 2500\nchunks = [large_dataset[i:min(i+chunk_size-1, end)] for i in 1:chunk_size:length(large_dataset)]\n\n# Process chunks (in real applications, use @distributed or threading)\nchunk_resamplers = [process_chunk(chunk, Minute(1)) for chunk in chunks]\n\n# Merge all results\nfinal_resampler = chunk_resamplers[1]\nfor i in 2:length(chunk_resamplers)\n    merge!(final_resampler, chunk_resamplers[i])\nend\n\nmerged_result = value(final_resampler)\nprintln(\"Merged OHLC: $(merged_result.ohlc)\")\nprintln(\"Total observations: $(nobs(final_resampler))\")\n\n","category":"section"},{"location":"tutorial/#Performance-Optimization","page":"Tutorial","title":"Performance Optimization","text":"","category":"section"},{"location":"tutorial/#Memory-Efficiency","page":"Tutorial","title":"Memory Efficiency","text":"OnlineResamplers uses constant memory regardless of data volume:\n\n# Memory usage stays constant even with millions of data points\nmemory_test_resampler = MarketResampler(Minute(1))\n\nprintln(\"Processing 1 million data points...\")\nfor i in 1:1_000_000\n    timestamp = DateTime(2024, 1, 1, 9, 0, 0) + Millisecond(i)\n    data = MarketDataPoint(timestamp, 100.0 + sin(i/1000), 1000.0)\n    fit!(memory_test_resampler, data)\n\n    # Memory usage remains constant due to window transitions\nend\n\nresult = value(memory_test_resampler)\nprintln(\"Current window has $(nobs(memory_test_resampler)) observations\")\nprintln(\"Memory usage is O(1) - constant regardless of total data processed\")","category":"section"},{"location":"tutorial/#Type-Stability","page":"Tutorial","title":"Type Stability","text":"For maximum performance, use concrete types:\n\n# Good: Concrete types\nfast_resampler = MarketResampler{DateTime, Float64, Float64}(Minute(1))\n\n# Less optimal: Abstract types (avoid if performance is critical)\n# slow_resampler = MarketResampler{Any, Any, Any}(Minute(1))\n\n# Concrete types enable compiler optimizations\nfunction high_performance_processing(resampler::MarketResampler{DateTime, Float64, Float64},\n                                   data_stream::Vector{MarketDataPoint{DateTime, Float64, Float64}})\n    for data in data_stream\n        fit!(resampler, data)\n    end\n    return value(resampler)\nend","category":"section"},{"location":"tutorial/#Batch-Processing","page":"Tutorial","title":"Batch Processing","text":"Process data in batches for optimal performance:\n\nfunction batch_process_ticks(resampler, ticks::Vector)\n    # Process all ticks without intermediate value() calls\n    for tick in ticks\n        fit!(resampler, tick)\n    end\n\n    # Get result only once at the end\n    return value(resampler)\nend\n\n# This is faster than calling value() after each fit!()\nbatch_resampler = MarketResampler(Minute(1))\nbatch_ticks = [MarketDataPoint(now(), 100.0 + randn(), 1000.0) for _ in 1:1000]\n\nresult = batch_process_ticks(batch_resampler, batch_ticks)\n\n","category":"section"},{"location":"tutorial/#Best-Practices","page":"Tutorial","title":"Best Practices","text":"","category":"section"},{"location":"tutorial/#1.-Choose-the-Right-Time-Period","page":"Tutorial","title":"1. Choose the Right Time Period","text":"# High-frequency trading: sub-second intervals\nhft_resampler = MarketResampler(Millisecond(100))\n\n# Algorithmic trading: minute-level\nalgo_resampler = MarketResampler(Minute(1))\n\n# Position management: hourly or daily\nposition_resampler = MarketResampler(Hour(1))","category":"section"},{"location":"tutorial/#2.-Handle-Time-Zone-Consistency","page":"Tutorial","title":"2. Handle Time Zone Consistency","text":"# Always use consistent time zones\nusing TimeZones\n\n# Convert all timestamps to UTC before processing\nfunction to_utc(local_time::DateTime, tz::TimeZone)\n    zoned_time = ZonedDateTime(local_time, tz)\n    return DateTime(astimezone(zoned_time, tz\"UTC\"))\nend\n\n# Process in UTC, display in local time as needed","category":"section"},{"location":"tutorial/#3.-Validate-Input-Data","page":"Tutorial","title":"3. Validate Input Data","text":"function safe_process_tick(resampler, timestamp, price, volume)\n    # Validate inputs\n    if price <= 0\n        @warn \"Invalid price: $price\"\n        return nothing\n    end\n\n    if volume < 0\n        @warn \"Invalid volume: $volume\"\n        return nothing\n    end\n\n    # Create and process data\n    tick = MarketDataPoint(timestamp, price, volume)\n    fit!(resampler, tick)\n    return value(resampler)\nend","category":"section"},{"location":"tutorial/#4.-Monitor-Window-Transitions","page":"Tutorial","title":"4. Monitor Window Transitions","text":"function monitored_processing(resampler, tick)\n    old_window = value(resampler).window\n    fit!(resampler, tick)\n    new_window = value(resampler).window\n\n    if old_window !== nothing && new_window != old_window\n        @info \"Window transition: $(old_window.start_time) -> $(new_window.start_time)\"\n        # Handle window completion logic here\n    end\nend","category":"section"},{"location":"tutorial/#5.-Error-Handling","page":"Tutorial","title":"5. Error Handling","text":"function robust_resampling(ticks)\n    resampler = MarketResampler(Minute(1))\n    successful_ticks = 0\n    errors = 0\n\n    for tick in ticks\n        try\n            fit!(resampler, tick)\n            successful_ticks += 1\n        catch e\n            @warn \"Failed to process tick: $tick\" exception=(e, catch_backtrace())\n            errors += 1\n        end\n    end\n\n    @info \"Processing complete: $successful_ticks successful, $errors errors\"\n    return value(resampler)\nend\n\n","category":"section"},{"location":"tutorial/#Conclusion","page":"Tutorial","title":"Conclusion","text":"OnlineResamplers.jl provides a powerful and flexible framework for real-time market data aggregation. Key takeaways:\n\nStart Simple: Begin with MarketResampler(Minute(1)) for basic OHLC resampling\nChoose Your Types: Use concrete types for performance, custom types for precision\nHandle Windows: Understand how time windows work and transition\nScale Up: Use parallel processing and merging for high-throughput applications\nMonitor Performance: Leverage constant memory usage and type stability for optimal speed\n\nFor more advanced usage patterns and examples, see the examples/ directory and the API reference documentation.\n\n","category":"section"},{"location":"tutorial/#Next-Steps","page":"Tutorial","title":"Next Steps","text":"Explore the API Reference for detailed function documentation\nCheck out Advanced Examples for complex use cases\nRead the source code for implementation details\nContribute improvements and new features!","category":"section"}]
}
